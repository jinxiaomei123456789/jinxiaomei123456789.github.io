<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初级考试]]></title>
    <url>%2F2019%2F02%2F11%2F%E5%88%9D%E7%BA%A7%E8%80%83%E8%AF%95%2F</url>
    <content type="text"><![CDATA[前言 学生时代虽然讨厌考试，但是每次考试基本上如鱼得水，大概我就是所谓的擅长考试的那一类人了。工作了依然是要考试的，考试时间在3月份，之前上网搜查了一下考试内容，除了一些操作性较强的，很多关于指导书上的考的都是一些测评指标的具体测评项，现在就来大致总结一下，方便日后回顾，以下内容皆是1.0标准的三级系统。 主机安全 主机安全测评分为两个部分:操作系统测评和数据库系统测评。 操作系统测评操作系统安全测评包含7个方面的内容：身份鉴别、访问控制、安全审计、剩余信息保护、入侵防范、恶意代码防范、资源控制。 身份鉴别1.应对登录操作系统和数据库系统的用户进行身份标识和鉴别2.操作系统和数据库系统管理用户身份鉴别信息应具有不易被冒用的特点，口令应有复杂度要求并定期更换。3.应启用登录失败处理功能，可采取结束会话、限制非法登录次数和自动退出等措施。4.当对服务器进行远程管理时，应采取必要措施，防止鉴别信息在网络传输过程中被窃听。5.应为操作系统和数据库系统的不同用户分配不同的用户名，确保用户名具有唯一性。6.应采用两种或两种以上组合的鉴别技术对管理用户进行身份鉴别。 访问控制1.应启用访问控制功能，依据安全策略控制用户对资源的访问。2.应根据管理用户的角色分配权限，实现管理用户的权限分离，仅授予管理用户所需的最小权限。3.应实现操作系统和数据库系统特权用户的权限分离。4.应严格限制默认账户的访问权限，重命名系统默认账户，修改这些账户的默认口令。5.应及时删除多余的、过期的账户，避免共享账户的存在。6.应对重要信息资源设置敏感标记。7.应依据安全策略严格控制用户对有敏感标记重要信息资源的操作。 安全审计1.审计范围应覆盖到服务器和重要客户端上的每个操作系统用户和数据库用户。2.审计内容应包括重要用户行为、系统资源的异常使用和重要系统命令的使用等系统内重要的安全相关事件。3.审计记录应包括事件的日期、时间、类型、主体标识、客体标识和结果等。4.应能够根据记录数据进行分析，并生成审计报表。5.应保护审计进程，避免受到未预期的中断。6.应保护审计记录，避免受到未预期的删除、修改或覆盖等。 剩余信息保护1.应保证操作系统和数据库系统用户的鉴别信息所在的存储空间，被释放或再分配给其他用户前得到完全清除，无论这些信息是存放在硬盘上还是内存中。2.应确保系统内的文件、目录和数据库记录等资源所在的存储空间，被释放或重新分配给其他用户前得到完全清除。 入侵防范1.应能够检测到对重要服务器进行入侵的行为，能够记录入侵的源IP，攻击的类型、目的、时间，并在发生严重入侵事件时提供报警。2.应能够对重要程序的完整性进行检测，并在检测到完整性受到破坏后具有恢复的措施。3.操作系统应遵循最小安装的原则，仅安装需要的组件和应用程序，并通过设置升级服务器等方式保持系统补丁及时得到更新。 恶意代码防范1.应安装防恶意代码软件，并及时更新防恶意代码软件版本和恶意代码库。2.主机防恶意代码产品应具有与网络防恶意代码产品不同的恶意代码库。3.应支持防恶意代码的统一管理。 资源控制1.应通过设定终端接入方式、网络地址范围等条件限制终端登录。2.应根据安全策略设置登录终端的操作超时锁定。3.应对重要服务器进行监视，包括监视服务器的CPU、硬盘、内存、网络等资源的使用情况。4.应限制单个用户对系统资源的最大或最小使用限度。5.应能够对系统的服务水平降低到预先规定的最小值进行检测和报警。]]></content>
      <tags>
        <tag>考试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[burpsuite与web安全基础]]></title>
    <url>%2F2019%2F01%2F24%2Fburpsuite%E4%B8%8Eweb%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ubuntu系统搭建php环境]]></title>
    <url>%2F2019%2F01%2F23%2Fubuntu%E7%B3%BB%E7%BB%9F%E6%90%AD%E5%BB%BAphp%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[ubuntu sudo apt-get install openssh-server 安装php安装php5.6sudo apt-get updatesudo apt-get install php5.6 安装扩展sudo apt-get install php5.6-gdsudo apt-get install php5.6-mysql 安装Apache2安装Apache2sudo apt install apache2sudo apt-get install libapache2-mod-php5.6 启动apache服务器service apache2 start验证apache安装成功，在本地电脑上浏览器中输入虚拟机IP地址，可以看到apache的默认界面 安装MySQLsudo apt install mysql-server php5.6-mysql这里输入两次密码sudo apt-get install mysql-client启动mysql服务： systemctl start mysql.service，输出结果如下 查看mysql服务是否已经启动：查看mysql进程，输入命令 ps -aux | grep mysql，可以看到存在mysql进程。 配色方案xshell终端中的配色不好看，在修改过程中误删了.bashrc文件，后面不管如何导入配色方案都不能有预期的效果，只能先恢复此文件，在linux中/etc/skel目录下是Linux的各种初始化配置文件存放目录。]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows]]></title>
    <url>%2F2019%2F01%2F23%2Fwindows%2F</url>
    <content type="text"><![CDATA[命令快捷键：win+r1.输入cmd windows的dos界面2.输入mstsc 弹出 windows的远程桌面连接界面，在windows属性中可以打开远程桌面功能，远程使用的是3389端口，需设置密码强度防止入侵。3.输入services.msc 直接打开windows服务。4.输入regedit 打开windows注册表5.control 打开控制面板 DHCPDHCP原理1.客户端发送广播包；2.服务器提供响应，在自己的数据库中查找可用地址交付（响应依然是广播包）3.客户端确认IP，服务器确认改地址已经被分配4.服务器确认租约5.当客户机重启或租期到达一半时，进行续租；租期间无法联系，租约到达后直接发送广播包。 DNS将域名转成IP地址，告诉主机应该从哪里请求数据。1.域名解析的系统判断顺序：c:\windows\system32\drivers\etc\hosts文件，然后是DNS缓存，最后是DNS服务器2.服务器判断顺序：本地缓存 本地数据 转发器]]></content>
      <tags>
        <tag>windows</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php基础]]></title>
    <url>%2F2019%2F01%2F22%2Fphp%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言 我因学习不做笔记浪费了大量时间，知识在学习之后遗忘，遗忘之后重新学地不断循环。走过坑，踩过雷。也曾或许未来也是地雄心壮志地一段时间，然而脑子里想着我要做再多的事要学再多的知识都是浮于表面，不去真正动手事情永远摆在脑海里，长此以往便让人身心疲惫。“你觉得累是因为想的多而做的少罢了”一位前辈曾经如此教导，细细一想，确实没错。迷茫时学习就对了，不想动只是给自己的懒惰找借口，我也算看清自己性格弱点以及内心不正道的想法了。 &emsp;&emsp;好好学习，天天向上。 php变量php代码格式`＜？php php代码 ?＞` php变量命名规则&emsp;&emsp;1.变量以 $ 符号开始，后面跟着变量的名称&emsp;&emsp;2.量名必须以字母或者下划线字符开头&emsp;&emsp;3.变量名只能包含字母数字字符以及下划线（A-z、0-9 和 _ ）&emsp;&emsp;4.变量名不能包含空格&emsp;&emsp;5.变量名是区分大小写的（$y 和 $Y 是两个不同的变量） 创建php变量&emsp;&emsp;PHP没有声明变量的命令，变量无需声明，在第一次给它赋值的同时就被创建。php是一门弱类型语言，不必向 PHP 声明该变量的数据类型。PHP 会根据变量的值，自动把变量转换为正确的数据类型。在强类型的编程语言中，我们必须在使用变量前先声明（定义）变量的类型和名称。 变量$&emsp;&emsp;在给变量赋值时即创建变量，那么$x赋值之后，在下面使用值时，能否直接使用x呢？&emsp;&emsp;答案是不可以的，因为$x一个整体代表中国变量，分开使用会报错，如下，为代码示例： &lt;?php $a = 5; echo a; ?&gt; ` &emsp;&emsp;上述代码，输出时只输出a，在浏览器中解释执行后报错如下： &emsp;&emsp;正确代码如下： 变量大小写&emsp;&emsp;代码示例如下： &lt;?php $a = 5; echo $A; ?&gt; `&emsp;&emsp;输出结果为: php变量引用 &lt;?php $a = 5; $b = 12; $a = &amp;$b; echo $a; ?&gt; `&emsp;&emsp;上述代码，首先给a,b两个变量开辟两个不同的空间，$a=&amp;$b;这句代码将变量a指向变量b所在的空间，这样，当这个空间的值为多少或者改变了，那么a和b两个的值都是一样的。所以上面代码输出值为12。 函数参数1.定义与使用&emsp;&emsp;php函数定义到调用如下：&emsp;&emsp;注意：函数生效必须调用，只定义函数内容不会执行。2.实参与形参当函数形参没有默认值时，调用函数时，实参参数个数必须与形参一致，否则报错。如下。当函数形参有默认值时，实参参数个数无需和形参个数相同。如下代码：3.静态变量静态变量只有第一次被初始化，在后面代码中继续用到函数体中的该静态变量时，不会再次执行初始化语句，变量值在上次执行后的基础上继续执行，如下面代码，输出$a的值一直是1，而$b的值则是3，第二次执行函数后是4： 数组定义1.第一种方法$arr = array(元素1，元素2，元素3…);2.第二种方法$arr[] = 元素1;//将元素1添加到$arr数组中；$arr[] = 元素2；//将元素2添加到$arr数组中； 遍历数组&lt;?php $arr = array(&apos;jin&apos;,&apos;21&apos;,&apos;网络安全&apos;); for($i=0;$i&lt;3;$i++){ echo $arr[$i]; echo &quot;&lt;br/&gt;&quot;; } ?&gt;]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php环境]]></title>
    <url>%2F2019%2F01%2F18%2Fphp%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[大二一段时间开始学习PHP，搭建环境用了一个多月，失败了，当时归结于三个软件版本下的不对有冲突，一个多月后最终使用了PHP的集成环境wamp，使用起来可以，但总觉得自己走的不是正儿八经的道路，最近学习渗透，教程里使用的也是PHP环境，一想都是痛苦的回忆，虽不想再捡起，但狠狠心还是撸起袖子加油干吧。1.管理员模式打开dos。2.卸载apache服务: sc delete Apache2.43.安装apache服务：httpd.exe -k install4.开启apache服务：net start Apache2.45.停止apache服务：net stop Apache2.4 6.php语法中，代码里出现mysql执行出错，改为mysqli即可。]]></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更换电脑的博客问题]]></title>
    <url>%2F2019%2F01%2F09%2F%E6%9B%B4%E6%8D%A2%E7%94%B5%E8%84%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;公司新发了一台笔记本，以往我还是使用自己的笔记本，某天，钟老师说：“你怎么不带公司发的笔记本，是不是嫌弃它比你的重？”说完阴险地笑了笑。组长听了这话，和颜悦色地对我说：“下次出项目还是统一一下电脑吧。”于是，这个星期我便换了新的电脑，新电脑上很多环境都要自己配，麻烦，但也权当是一个知识的回顾过程吧。首先，便是换电脑之后hexo博客如何继续更新的问题，以下是解决步骤。 工具下载NodeJs下载与环境配置&emsp;&emsp;在官网上下载NodeJs，一路next,选择安装地址时为D:\kit\node.js，完成后在cmd控制台中输入node -version提示node不是命令，这是因为在系统变量path中没有将D:\kit\node.js路径加进去，添加好之后再次输入还是无效，重新启动后成功，想来我自己的电脑是win7是不用重新启动的，而新电脑是win10，必须要重新启动。控制台中输入node -v显示如下信息说明安装成功。 Git下载与配置&emsp;&emsp;在官网上下载Git工具，安装步骤网上有很多，安装结束后，桌面点击鼠标右键，看到有下图说明安装成功。 hexo安装&emsp;&emsp;在cmd窗口中输入npm install hexo-cli -g来安装hexo，结束后输入hexo -v可以查看安装是否成功。 在GitHub官网上添加新电脑产生的秘钥 1.首先配置Git的用户名和邮箱。2.输入命令在电脑上生成新的SSH KEY。连续点击三次“enter”键。如果电脑上之前已经生成过SSH KEY，那么新的会覆盖旧的。 打开电脑，可以看到电脑上生成了两个秘钥，秘钥生成算法为RSA算法，第一个文件是私钥，自己保留，不能给旁人知道，下面一个pub文件是公钥，大家都可以知晓。 打开公钥文件，复制添加到GitHub官网上。 配置结束后，测试配置是否成功。总结&emsp;&emsp;当能够看到这篇博客时说明我已经成功了，在我打字时刻内心依然非常欣喜，在这不断探索不断修改直至看到效果的过程中，我备受鼓舞，想起一年多前一位大神学长曾经教导的话，做技术做学问要脚踏实地，我走着他经历过的路，遵循着他说过的话，不断去踩坑。很多事情其实很明了，坑都是自己挖的却还未看透继续在捯饬着，比如，在做完这一切配置后，我这篇博客在首次发布的时候图片不显示了，检查好几遍都没什么问题，最后的最后发现图片前面的感叹号!是中文模式下输入的……]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络]]></title>
    <url>%2F2019%2F01%2F08%2F%E7%BD%91%E7%BB%9C%2F</url>
    <content type="text"><![CDATA[前言&emsp;&emsp;网络方面很多知识在大三学习的，计算机网络与网络安全这两门都是信息安全系主任葛斌老师授课，我们习惯叫他葛大爷。葛大爷苦口婆心教导每一个知识点，每次上课前随机点名抽取上一堂课的问题让学生回答，问题长达十个都有，在他教授这两门课的过程是我们大学时代最最黑暗的时光了，每次他上课的前两天宿舍就开始不分昼夜地背书，问问题，问原理，他上的每一次课，提前十分钟教室就坐满了人，教室里笼罩着恐怖气息，个个盯着书本嘴里念念有词还手舞足蹈（紧张地），仿佛下一秒就要变成哈利波特骑着扫把飞走了。 &emsp;&emsp;这样的好处是期中期末考试时，班上几乎没有人在这两门课上花时间，因为所有知识都滚瓜烂熟了，感谢葛大爷！！！而距离现在已经快两年没有接触网络了，在工作学习甚至是面试考试中又或多或少会遇到，索性这次就去回顾学习一番。 什么是计算机网络&emsp;&emsp;计算机网络是指由两台或两台以上的计算机通过网络设备连接起来所组成的一个系统，在这个系统中计算机与计算机之间可以进行数据通信、数据共享及协同完成某些数据处理的工作。这里的计算机不仅仅指我们的电脑，其实指的是所有在网络中的网络设备，比如手机，平板电脑等。 计算机之间如何进行通信&emsp;&emsp;有了计算机等设备，也就得考虑如何连接起来他们，这就是他们之间该如何通信的问题。对计算机来说，就是一个硬件设备，如何让计算机与计算机连接起来，必需需要软件的支撑。那么支持计算机通讯的软件是什么呢？就是计算机网络参考模型。这个计算机网络参考模型就是计算机网络软件。最经典的当然是国际化标准的OSI（Open System InterConnect 开放式系统互联）参考模型。它是通过一个机器上的一个应用进程与另一个机器上的进程进行信息交互。下面我们了解下这个模型。 网络模型OSI七层模型&emsp;&emsp;OSI七层模型（从下到上）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。同层之间相互进行通信，下层为上层提供服务。OSI参考模型如下图所示。 &emsp;&emsp;物理层：物理层向上为数据链路层传输比特流，这一层的数据单位是比特（bit）,协议有Rj45，802.3等。&emsp;&emsp;数据链路层：负责在单个链路节点上传输以帧为单位的数据。协议有ATM，FDDI等。&emsp;&emsp;网络层： 网络层传送的数据称为分组或包(packet)，在物理网络间传送分组，负责将源端主机的报文通过中间转发结点传送到目的端。网络层主要负责分组转发和路由选择，根据路由表把分组逐跳地由源站传送到目的站，并能适应网络的负载及拓扑结构的变化，动态地更新路由表。协议有：IP,IPX等。&emsp;&emsp;传输层： 传输层传输的数据称为报文(message)，传输层为源结点和目的结点的用户进程之间提供端到端的可靠的传输服务。协议有：TCP，UDP等。&emsp;&emsp;会话层：会话层在传输层服务的基础上增加控制会话的机制，建立、组织和协调应用进程之间的交互过程。会话层提供的会话服务种类包括双工、半双工和单工方式。协议有RPC，SQL等。&emsp;&emsp;表示层：表示层定义用户或应用程序之间交换数据的格式，提供数据表示之间的转换服务，保证传输的信息到达目的端后意义不变。协议有：GIF，JPEG，等。&emsp;&emsp;应用层：这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。协议有：telnet，HTTP,FTP,NFS,SMTP等。 TCP/IP模型&emsp;&emsp; TCP/IP模型（从下到上）：物理层、数据链路层、网络层、传输层、应用层。模型图如下。 TCP的三次握手 &emsp;&emsp;TCP(Transmission Control Protocol) 传输控制协议，是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接，TCP的标志位又称为位码，在三次握手过程中有6种标示：&emsp;&emsp;SYN(synchronous建立联机)：建立连接，设置为1，SYN这个标志位只有在TCP建产连接时才会被置1，握手完成后SYN标志位被置0。&emsp;&emsp;ACK(acknowledgement确认) ：占1位，仅当ACK=1时，确认号字段才有效。ACK=0时，确认号无效 。&emsp;&emsp;PSH(push传送)：提示接收端应用程序立即从TCP缓冲区把数据读走。&emsp;&emsp;FIN(finish结束)：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接&emsp;&emsp;RST(rest重置)：对方要求重新建立连接，复位。&emsp;&emsp;URG(uegent紧急)：紧急指针是否有效。为1，表示某一位需要被优先处理 。&emsp;&emsp;seq(Sequence number序列号码)：序列号seq就是这个报文段中的第一个字节的数据编号，随机产生。&emsp;&emsp;ack(Acknowledge numbe确认号码)：期待收到对方下一个报文段的第一个数据字节的序号，值为seq+1.&emsp;&emsp;在建立连接过程中客户端TCP状态变化如下：&emsp;&emsp;CLOSED-&gt;SYN_SENT-&gt;ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSED&emsp;&emsp;在建立连接的过程中服务器端TCP状态变化如下：&emsp;&emsp;CLOSED-&gt;LISTEN-&gt;SYN-RECEIVED-&gt;ESTABLISHED-&gt;CLOSE_WAIT-&gt;LAST_ACK-&gt;CLOSED&emsp;&emsp;TCP建立连接的三次握手过程文字描述如下：&emsp;&emsp;第一次握手：客户端A发送位码为SYN＝1,随机产生seq number=1234567的数据包到服务器B，服务器B由SYN=1知道，客户机A要求建立联机；&emsp;&emsp;第二次握手：服务器B收到请求后要确认联机信息，向客户机A发送ack number=(主机A的seq+1),syn=1,ack=1,随机产生seq=7654321的包。&emsp;&emsp;第三次握手：客户机A收到服务器B发来的数据包后检查ack number是否等于客户机A第一次发送的seq number+1,以及位码ack是否为1，若正确，客户机A会再发送ack number=(服务器B的seq+1),SYN=0，ack=1的数据包给服务器B，服务器B收到后确认seq值与ack=1则连接建立成功。&emsp;&emsp;TCP的三次握手模型图如下所示： TCP的四次挥手&emsp;&emsp;TCP的连接断开需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。&emsp;&emsp;客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。&emsp;&emsp;服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v。&emsp;&emsp;服务器B关闭与客户端A的连接，发送一个FIN给客户端A。&emsp;&emsp;客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。&emsp;&emsp;TCP四次挥手如下图： 问题&emsp;&emsp;为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？&emsp;&emsp;这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送。但关闭连接时，当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但未必你所有的数据都全部发送给对方了，所以你可能未必会马上会关闭SOCKET,也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的ACK报文和FIN报文多数情况下都是分开发送的。 TCP与UDP的区别&emsp;&emsp;1、TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接。&emsp;&emsp; 2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达;UDP尽最大努力交付，即不保证可靠交付。Tcp通过校验和，重传控制，序号标识，滑动窗口、确认应答实现可靠传输。如丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。&emsp;&emsp; 3、UDP具有较好的实时性，工作效率比TCP高，适用于对高速传输和实时性有较高的通信或广播通信。&emsp;&emsp; 4.每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信。&emsp;&emsp; 5、TCP对系统资源要求较多，UDP对系统资源要求较少。 UDP优势&emsp;&emsp;UDP以其简单、传输快的优势，在越来越多场景下取代了TCP,如实时游戏，原因如下。&emsp;&emsp;1.网速的提升给UDP的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。&emsp;&emsp;2.TCP为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于TCP内置的系统协议栈中，极难对其进行改进。&emsp;&emsp;3.采用TCP，一旦发生丢包，TCP会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大，基于UDP对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。 IP地址相关IP地址计算&emsp;&emsp;例题：子网掩码是255.255.255.0，能容纳多少台电脑？]]></content>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESXI填坑]]></title>
    <url>%2F2019%2F01%2F07%2FESXI%E5%A1%AB%E5%9D%91%2F</url>
    <content type="text"><![CDATA[前言 前段时间听所里小哥聊天，整个测评部能够做渗透测试的只有旭哥一个人，惊讶得很，这几天便开始了我的渗透之路，遇上很多坑，记录如下，以防后面查缺补漏增加学习和工作效率。 新建虚拟机后IP地址分配不对 在新建虚拟机后，分配到的IP地址为169开头或者是0.0.0.0，这是因为电脑中还有其他的虚拟网卡，禁用掉除此虚拟机之外的网卡再新建虚拟机地址即可分配正确，一般都是以192.168开头的IP地址。禁用网卡位置如下图。 虚拟机开机分配动态IP地址 新建虚拟机结束后，使用客户端连接服务器，第一次成功，后来第二此重启服务器后再连接就失败了，这是因为虚拟机中IPV4设置中，有一项默认设置是：使用动态IP地址，我们需要把这一项修改为使用静态IP地址，按F2进入系统配置，详细设置见下图。 客户端连接报错 使用客户端连接报错：在服务器192.168.2.3上调用对象“ServiceInstance”的“ServiceInstance.RetrieveContent”失败。这个错误原因是因为虚拟机没有开启SSH功能。按F2进入系统配置后选择“Troubleshooting Mode Options”，进入后将关于ssh的设置为enabled即可，如下图。]]></content>
      <tags>
        <tag>ESXI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[课外拓展之电脑硬件]]></title>
    <url>%2F2019%2F01%2F02%2F%E8%AF%BE%E5%A4%96%E6%8B%93%E5%B1%95%E4%B9%8B%E7%94%B5%E8%84%91%E7%A1%AC%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[１.cpu cpu在操作系统中用于做浮点运算。电脑cpu主要有两个品牌，intel和AMD。下面以intel某一产品介绍cpu的配置。 1. cpu内核因素 cpu架构：64位。如果自己的电脑是32位的系统，cpu为64位就不适用。 核心数量：六核心。 线程数量：12。线程数量刚好是核心数量的双倍，源于intel特有的技术：超线程，意思是在操作系统中一个核心可以当两个cpu来用。 2. cpu频率 主频：在预算范围内，主频越大越好。 3. cpu插槽 插槽类型：LGA 2011，不同的CPU有不同的插槽，插槽之间不通用。 4. cpu技术 超线程技术：支持。如前面所说的，如果支持超线程技术，一般都是线程数量是核心数量的两倍，目前还没有三倍技术。 虚拟化技术：Intel VT。CPU之处虚拟化指定工具才能安装。 5. cpu内存 适用类型：台式机。指定内存安装在台式机还是笔记本。 内存容量：8GB。 内存类型:DDR3。内存类型还有其他，如DDR2，DDR4等，他们之间不同之处在于，在内存条从DDR2到DDR3到DDR4做升级时，修改缺口的位置不同，但主板上的总长度不变。缺口位置如下图所示。 6. 虚拟化 虚拟化是指通过虚拟化技术将一台计算机虚拟化为多台逻辑计算机。在一台计算机上同时运行多个逻辑计算机，每个逻辑计算机可运行不同的操作系统，并且应用程序都可以在互相独立的空间内运行而互不影响，从而显著提高工作效率。]]></content>
      <tags>
        <tag>硬件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019年计划]]></title>
    <url>%2F2018%2F12%2F29%2F2019%E5%B9%B4%E8%AE%A1%E5%88%92%2F</url>
    <content type="text"><![CDATA[转眼间已到了2018年的最后第三天，回首过去的一年，基本处于颠沛流离的状态。17年十月份找了一份安卓系统开发的工作，12月进部门之后几乎就没有了自己的生活，每天早上六点多起床，晚上几乎都在十点左右到家，一两点到家的也有几次，加班于当时的我来说是常事，时间全部奉献给了无数的客户需求、bug和版本维护，以及无休无止的patch。 以为这样的生活会锻炼出我在专业领域愈加丰富的经验，然而并没有达到预想的效果。跳槽的想法在公司开始产业转移时产生，手机已不是公司的新宠，人工智能才是未来社会发展的大方向。其次，伴随着产业转移带来的一系列矛盾渐渐浮出水面，员工人事调整以及财务危机渐渐摧垮了大家对工作的积极性，于是，在一个夜黑风高的时刻，我离职了。 11月份我来到了新公司，一家事业单位，新工作要求知识面广，需要和客户交流，这样的工作正好给我一个锻炼社交的机会，于是我决定在这里脚踏实地的干下去。 19年我的计划是考等级保护证书，元旦之后每天晚上回家有空了就去学习关于渗透的内容，计划明年年底将渗透学熟练。]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali安装教程]]></title>
    <url>%2F2018%2F12%2F26%2Fkali%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言 五个月之前因为兴趣接触了kali，从安装到基本命令以及一些黑客常用技术算是系统过了一遍，然而，这段时间没有碰现在全部忘记了，连基本的安装不会。博客是一个好东西，督促我不断学习，之前对自己太自信了，总以为自己过目不忘，然而却被现实打倒，好记性不如烂笔头，算是对自己的一个教训了，现在深刻地认识到做技术写博客是多么重要的一件事，一来回顾，二来查缺补漏，最后也是对自己职业生涯的一种见证与规划吧。一位学长曾告诉我们学习要脚踏实地，苦口婆心的劝说我也没能听进去多少，工作了才意识到，下面就从最基本的安装开始，听过来人的话把地踩塌。 打开vmware，一次选择“文件”-&gt;“新建虚拟机”，弹出以下界面，选择“典型”，点击“下一步”。 选择“稍后安装操作系统”，点击“下一步”。 下面的选项除了第一个是选择Linux，第二个我在安装过程中选择centos和ubuntu都可以。选择之后点击“下一步”。 这一步首先需要给你的虚拟机命名，下面一个就是设置新建虚拟机的存储位置，设置好之后点击“下一步”。接下来的步骤都是默认。 新建结束之后，需要配置系统镜像，鼠标放置在虚拟机上右击，点击“设置”。 选择CD/DVD这个选项，在右边”使用ISO镜像文件“中设置我们下载好的镜像文件，点击“确定”。到目前为止虚拟机就新建好了，下面我们需要启动虚拟机，启动过程中会有一些系统设置。 鼠标放置在我们新建的虚拟机上，右击“电源”-&gt;“启动客户机”。出现图形界面，选择“Graphical install”，enter键。 选择语言“简体中文”。 选择“中国”，点击”继续“。 下面选择“汉语”。稍等一会儿出现主机名配置。配置好之后点击“继续”。 接下来是域名配置，直接跳过，enter键。 设置密码，这个密码就是开机密码，我设置为root。 选择第一个 选择如下： 下面的步骤直接默认，直到出现以下。选择“是”。 接着有一个漫长的等待过程。 然后会问你是否要选择网络镜像，如果你的网络很好可以选择是，这里呢我选择的否。都行的。接下来都是默认。 出现这一步选择“是”。 选择第二个。 出现这个的时候就说明安装结束了，点击继续现在开始你的黑客之旅吧。]]></content>
      <tags>
        <tag>kali</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[与德工作记录]]></title>
    <url>%2F2018%2F12%2F25%2F%E4%B8%8E%E5%BE%B7%E5%B7%A5%E4%BD%9C%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前两日在忙项目归档，今天得空回顾一下自己在与德工作一年以来的记录。与德访问控制这个方面做的很好，但还是屈服于互联网科技的迅速发展，大多数同事都使用有道云笔记来记录工作中遇到的问题以及学到的新知识，我也随了他们的习惯。 1. 单编 单编是指只编译一个模块，一般系统代码中具有.mk文件的都可以进行单编，结束后将单编后的apk等文件拷贝到版本通道，在push到手机中即可验证bug和feature是否修改成功。单编从整体上来说比make或者new编译节省大量时间，并且不用刷机验证，以下为单编步骤，以Launcher3为例： 首先：source build/envsetup.sh 接着执行lunch 然后选对应的版本 最后mmma packages/apps/Launcher3(使用mmma的权限比mmm的权限更大，它会编译到一些更加底层的库文件，有时候mmm不能成功的可能就是因为库文件没有找到，这时可以使用mmma来编) 2. 关于抓log 通过adb抓取手机运行过程中生成的log，具体做法先把手机打开开发者模式，连接电脑，打开usb调试，如果我们想让生成的log在指定的位置，比如E盘，那么直接E: 接着在里面输入adb logcat -v time&gt;1.log，这里的1.log就是生成的log文件的名称，按“Ctrl+C”终止抓log。 3. 关于解bug 2018.7.27，截止现在，我解了快一个月的bug，之前在四部从来没有解过，这段时间的工作，让我增长了很多方面的知识，对于解bug，有了暂时的心得，记录下方便下次回顾。 真正意义上我开始解的第一个bug是手机设置中查看SIM卡信息，IMEI等信息时报“com.android.phone&quot;停止运行，组长过来询问我工作如何，我乘机问了一下他关于解bug的流程以及如何找到原因并解决这个bug。现在凭借我仅存的记忆记录如下。 首先，看到一个bug之后，先在自己的手机上刷最新的版本，验证是否会出现和测试那边描述的一样的现象，如果没有出现，可能是后期别人提交的代码没有合上去，导致测试那边不能通过，也可能是操作手法不对，在这种情况下，要和测试那边提出这个bug的小伙伴沟通。在肯定最新版本没有这个问题时，就关闭这个bug并且在下面备注“在某月某日验证通过，请在下个版本验证”。 确定最新版本出现同样的现象之后，连接电脑抓log，之前一直用的是adb命令形式，adb logcat -v time&gt;1.log，后来发现我自己的nodepad++安装了抓log的插件，点击就可以抓。抓完log之后分析。一般情况下，像这种程序异常结束的，我们搜索的关键字有“exception”、“fail”、“crush”等。搜索定位到具体的某个类的某个方法，接下来就开始看源码，修改。这个部分就要凭经验。今天成功改了一个bug之后，我认为首先要会猜某段代码究竟是干嘛的，安卓代码量100多G，这么大，不可能每段代码的含义，每个变量的含义我们都知道，在定位到具体方法后，大胆修改去尝试很重要。 在试用期间，我从对安卓系统开发的理论理解上升到现在的实际工作，从一开始的基础工作到现在学习如何解bug，每一项工作都学习到了很多知识和经验。 前期发版本过程中，最重要的心得就是要胆大细心，这项工作但凡有一点疏忽，花半天编的版本就有问题，其次，在编译版本之前要再三和这个项目的开发经理确认打patch的时间、gms包的版本、版本号以及修改点是否都是正确的，千万不能想当然，我因为这几个问题犯了几次错，给了我沉痛的教训，所以现在一有改需求后发版本的工作都战战兢兢。 合patch是一项锻炼人意志的工作，在这个过程中小心驶得万年船。再枯燥的工作也有可以学习的地方，因为合patch，我掌握和如何使用git提交、回退以及查看提交记录等。 解bug是一点一点积累经验的过程，从一开始连步骤都不会到现在可以独自解bug，这段时间经历了收获了很多，也经历了很多迷茫，在海军、组长、师父以及其他同事的帮助下，度过了这一段迷茫期。最重要的是定位问题，抓取了log之后，要搜索什么样的关键词去定位文件是解bug的敲门砖，这个只有通过经验来慢慢积累，其次，定位了问题之后，我不知道该如何修改，前辈们教我不知道如何修改的时候，要学会看代码猜含义，不懂的百度搜，百度内容可能不是很透彻，但是加入我们自己的理解代码就比较好懂了，这时大胆修改代码去验证自己的修改是否是正确的。 之前我每次修改完都remake编译一下去刷版本，但解bug时才发现，这样太浪费时间了，能够单编的尽量去单编，非常节省时间。 关于单编，有时用mmm编译报错，显示大致意思是缺少文件，问了旁边的海军后才明白，mmm的权限比mmma的小，有的库文件编译需要用但是编译用mmma可以编译到更多的库文件。 4. git管理工具 工作中学到最有用的便是git，只想说git的发明者是一个非常了不起的人,很感谢这段工作经验。 E628_O项目的提交步骤如下： git status . 看修改了哪些文件， 如果有不需要提交的文件A，直接rm -rf A将文件A删除之后执行git add . 之后依次执行git add .和. git_ci.sh E628_GIG，这一步就相当于git commit .操作，执行了这一步之后就不需要再执行commit了。之后执行repoc upload .,有的也会用repo upload . 提交到服务器上之后，如果发现有不需要提交或者提交错的文件，需回退代码，回退到刚刚修改完文件的状态，首先要看提交日志，查看提交日志使用git log,这里的回退是只有自己本地代码回退，不是服务器上的，使用git reset ffw2395742432，执行完这一步，将不需要提交的文件删除，再执行git add .或者执行执行git add 文件名，提交顺序和上面一样。 5. Linux命令 (1)查找文件 例如查找a.java这个文件，使用命令find * -name &quot;a.java&quot; (2)找某个文件中具体字段被哪些文件引用 grep --exclude &quot;colors.xml&quot; -rn &quot;badge_color&quot; ./ (3)更新代码：更新代码git pull (4)查看当前应用的包名:打开当前应用，手机开发者模式直接输入改命令adb shell &quot;dumpsys window | grep mCurrentFocus&quot; 6. 未接来电和未读短信等通知改成红色小图标 在gerrit上面看了同事的提交记录，修改的是packages/apps/Launcher3/res/values/colors.xml文件中的“badge_color”和“folder_badge_color”这两个字段，将其修改为红色“#FF0033”。 使用grep --exclude &quot;colors.xml&quot; -rn &quot;badge_color&quot; ./ 在Launcher对应的目录下面搜索，发现这个字段在IconPalette.java函数getBadgePalette()中被引用，打开 12345678int badgeColor = resources.getColor(R.color.badge_color);if(badgeColor == Color.TRASPARENT)&#123;return null;&#125;if(sBadgePalette==null)&#123;sbadgePalette = fromDominantColor(badgeColor,false);&#125;return sbadgePalette ; 我对这段代码的理解就是，先获得定义好的颜色，判断，如果颜色是透明的（TRASPARENT），直接返回空，如果sBadgePalette（应该是类似画笔之类的对象）是也是空，那么，就根据我们获取到的颜色badgeColor去画，把它保存在sbadgePalette 对象中，最后返回此对象。 之后看这个函数在哪里被调用，在Launcher3目录下执行grep --exclude &quot;IconPalette.javal&quot; -rn &quot;getBadgePalette&quot; ./ ，出现了两个文件，一个是PopupContainerWithArrow.java的671行，打开看了一下，它被调用的地方在函数&quot;updateNotificationHeader()&quot;中，根据函数名，应该是更新通知头之类的含义，在这个函数中，大致含义应该是：如果通知界面和信息界面都不是空，说明有未接电话或者未读信息等通知，这时，就创建一个图标画笔，画笔的内容就是getBadgePalette（）的返回值，也就是我们定义的红色，即用红色画出一个图标，然后把图标显示在界面上。 7. apk覆盖问题 今天做的一个需求就是修改未接电话或者未读短信等通知的图标为红色，我修改的地方是packages/apps/Launcher3这个目录下面的res/values/color.xml文件，但是后来同事告诉我不能在这个地方修改，原因是MTK很多apk会被vendor目录下面的packages/apps覆盖。我的问题是，如何看一个apk究竟是packages下面的还是vendor下面的呢？主管告诉我可以通过查看编译生成的out目录的app名字来反推。比如本次修改的Launcher3,查看编译生成的apk名字是mtkLanucher3，在packages/apps下面，打开自己的Android.mk文件，属性local_package_name:=Launcher3,但是在vendor下面，这个属性值为mtkLanucher3,就是编译生成的out中的apk的名字。 其次就是编译生成的out/system下有一个app还有一个priv-app目录，他们的区别在与，后者是系统中重要的apk，如何将一个应用编译时生成到pri-app中呢？需要在Android.mk中做如下设置即可：LOCAL_PRIVILEGED_MODULE := true，如果是false就编译到app中。 8. Android系统紧急号码 修改vendor目录下面的ecc_list.xml文件，将我们需要添加的号码加进去，如添加112为紧急号码：&lt;EccEntry Ecc=&quot;112&quot; Category=&quot;0&quot; Condition=&quot;0&quot;/&gt;添加参数condition时，0表示在无卡的时候当紧急号码，1表示始终当紧急号码，2表示洁面霜显示成紧急号码但是实际是以普通方式拨出。 9. Android系统设置中移除短信通知 控件的移除要通过父控件来移除 12if(enabled) ((PreferenceCategory)findPreference(KEY_SIM_ACTIVITIES)).removePreference(findPreference(KEY_SMS))； 这段代码在vendor/mediatek/proprity/packages/apps/MtkSetting/Sim下面，打开这个文件之后，找到updateSmsValues()函数，函数分析下：（1）final Preference simPref = findPreference(KEY_SMS)这里需要注意的是Preference是一种布局，这句话的含义就是，找到KEY_SMS这个字段的布局赋给simPref 。（2）找KEY_SMS布局在什么地方，在source insight中ctrl并点击这个变量，发现在SimSettings.java函数中定义的位置，得知它保存的字符串是&quot;sim_sms&quot;，如何找“sim_sms”在哪里被定义呢？方法：鼠标放置在“sim_sms”上，按“ctrl+/”点击确定，等搜索结果出来了之后点击前面的符号就能进入被定义的地方，这里我们看到的是改布局在Sim_setting.xml文件中被定义，点开，看到sim_sms是一个preference的key，通过这个key和findprefrence(key)就能找到该布局。搜索这个布局的@string，看到该布局表示的是“短信”。 10. java序列化 在公司电脑上安装开发软件以及配置环境，电脑内存只有4G，非常卡，无情吐槽…… 1.下载工具 工具选择intelliJ IDEA，打开官网下载最新版本的2018.1.5，一共有两个版本，一个是ultimate还有一个是community，之前也听过分为商业版和社区版，但是因为下载成功了也没有特别注意区别。第一次下载的是community这个版本，但是在配置tomcat的时候发现没有tomcat server这个选项，正确的是下载的时候选择ultimate商业版。2.java序列化代码 注意点：序列化的类实现serializeble接口。ObjectOuptPutStream用于对象的读出流，在序列化的时候，首先实例化一个对象，再创建一个.txt文本用于保存序列化的对象。ObjectInputStream用于对象的读入流。具体代码如下：1234567891011121314151617181920212223242526272829303132package com.aust.serializable;import java.io.*;/** * Created by jinxiaomei on 2018/7/5 */public class serializableTest &#123; public static void main(String[] args) throws Exception &#123; serializeStudent(); Student student = deSerializaStudent(); System.out.printf(student.toString()); &#125; private static void serializeStudent() throws Exception&#123; Student stu1 = new Student(); stu1.setId(1); stu1.setName(&quot;jinxiaoemi&quot;); stu1.setPwd(&quot;123456&quot;); ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;E:/doc/serialize.txt&quot;))); oos.writeObject(stu1); System.out.printf(&quot;Student序列化成功！&quot;); oos.close(); &#125; private static Student deSerializaStudent() throws Exception&#123; ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;E:/doc/serialize.txt&quot;))); Student stu2 = (Student) ois.readObject(); System.out.printf(&quot;Student反序列化成功&quot;); return stu2; &#125;&#125;]]></content>
      <tags>
        <tag>android 系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微盟项目总结]]></title>
    <url>%2F2018%2F12%2F20%2F%E5%BE%AE%E7%9B%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.使用腾讯云的客户，一般主机使用的防恶意代码软件为腾讯云主机产品：云镜，云镜为用户提供黑客入侵检测和漏洞风险预警等安全防护服务，主要包括密码破解拦截、异常登录提醒、木马文件查杀、高危漏洞检测等安全功能，解决当前服务器面临的主要网络安全风险，帮助企业构建服务器安全防护体系，防止数据泄露。 云镜有两个版本，分别为基础防护和专业防护，访谈时需问清楚客户使用的是哪个版本。 具体版本差异腾讯官网有如下介绍，专业防护比基础防护拥有更多的功能。 ２.zabbix是分布式开源监控系统，主要是对服务器资源进行监控，默认的用户名为admin,密码是zabbix。监控内容包括CPU负荷、内存使用、磁盘使用、网络状况、端口监视、日志监视。在监控值达到设定阀值时提供报警，在访谈时，需询问客户使用何种方式进行报警。它和云镜的区别在于，云镜在发现入侵行为时会做出拦截等动作，但zabbix主要功能是监控。 3.WAF是web应用防火墙，作为网络防恶意代码产品使用。测评项中有一项为“主机防恶意代码产品与网络防恶意代码产品是否具有不同的恶意代码库”，这个主要看产品是否相同，例如：客户主机防恶意代码产品使用的是腾讯云的云镜，网络防恶意代码产品使用WAF，则恶意代码库就不相同。 4.堡垒机作用是它切断了终端计算机对网络和服务器资源的直接访问，采用协议代理的方式，接管了终端计算机对网络和服务器的访问。形象地说，终端计算机对目标的访问，均需要经过堡垒机的翻译。打了一个比方，堡垒机扮演着看门者的工作，所有对网络设备和服务器的请求都要从这扇大门经过。因此堡垒机能够拦截非法访问和恶意攻击，对不合法命令进行命令阻断，过滤掉所有对目标设备的非法访问行为，保障企业数据安全。 堡垒机的双因子登录为：用户输入堡垒机的用户名和密码，接着点击收到验证码，这时用户会收到一串验证码，填写正确方可登录成功。询问时需注意：询问堡垒机的厂商，部署方式，验证码以何种方式发送（短信或者微信）以及验证码的组成部分。]]></content>
      <tags>
        <tag>云镜 WAF zabbix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试图片]]></title>
    <url>%2F2018%2F12%2F14%2F%E6%B5%8B%E8%AF%95%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[步骤：在hexo下执行：npm install hexo-asset-image –save（已经执行过了，之后的不需要再执行这一步，只需要执行hexo n “博客名”）;运行hexo n “博客名”来生成md博客时，会在_post目录下看到一个与博客同名的文件夹；将想要上传的图片先扔到文件夹下，然后在博客中使用markdown的格式引入图片：]]></content>
      <tags>
        <tag>测试图片</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Shell 脚本学习]]></title>
    <url>%2F2018%2F12%2F07%2FLinux-Shell-%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[Linux相关知识在大三学的，迄今为止因为工作需要以及个人心血来潮断断续续学了一部分，导致现在对Linux只知命令，其他理解都不透彻。学习原因在于目前工作发现和Linux还是要经常打交道，在客户现场询问时客户输入的命令以及展示的内容都不懂！尴尬。。。。。。现在就利用闲暇时间，系统学习一遍，参考书籍为《Linux命令行与shell脚本编程大全第三版》 @[TOC]目录 1.基本的bash shell命令##1.1系统用户/etc/passwd 文件中包含着系统中所有账户列表以及每个账户的配置信息，示例如下： 2.tail -f显示文件变化]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[熊猫项目总结]]></title>
    <url>%2F2018%2F12%2F06%2F%E7%86%8A%E7%8C%AB%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.Linux普通用户切换到超级用户root:su - root接着会提示输入root的密码，正确即可进入。同样，切换到普通用户:su - jin(用户名)]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息安全之主机测评过程中遇到的linux命令]]></title>
    <url>%2F2018%2F11%2F30%2F%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E4%B9%8B%E4%B8%BB%E6%9C%BA%E6%B5%8B%E8%AF%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84linux%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Linux主机1.查看linux密码文件内容（1）cat /etc/passwd 此命令输出的口令是“x”，已被映射到/etc/shadow文件中。若没有X则表明没有设置密码。（2）cat /etc/shadow此命令能查看详细的密码。密码已被加密。综合上面两个命令，我在kali系统中设置密码为空时依然存在”x”,所以还是直接使用cat /etc/shadow更加直观看出有没有密码存在。 2.hexo创建新博客：hexo new “新文章”提交步骤：hexo g、hexo s、hexo d]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户登录注册模块]]></title>
    <url>%2F2018%2F03%2F18%2F%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[毕业设计——day01]]></title>
    <url>%2F2018%2F03%2F18%2F%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%2F</url>
    <content type="text"><![CDATA[计划 １.任务：用户登录及注册 ２.时间：2018.3.18-2018.3.24 步骤 １.很长时间没有接触到做网站的知识，好多操作都忘记了，重新开始学习。４月２０号要交代码啊！！！烦人！！！！！！不想这么快就打开电脑，为了生活还是好好敲吧。 我追崇成功之后的成就感，却对失败时无力的自己深恶痛绝。 2.先做了学生登录这一模块，在一般的学校中，学生只要入学账号自动存在，所以对于学生来说他们不需要去注册，只需要登录账号和修改密码，这里对应的数据库操作是select和update。学生登录模块，如何将学生输入的数据提交到后台controller中，之前我的方法是使用ajax提交，这个好处是可以在输入用户名的时候就可以检验出用户名是否被占用，但是在后台返回页面时，由于form表单的提交固定，所以两个页面会覆盖，故舍弃了使用ajax同步验证的方法，用了普通的表单提交，action=”${pageContext.request.contextPath}/StudentLogin”，controller中代码： @RequestMapping(value = “StudentLogin”,method = RequestMethod.POST) public ModelAndView StudentLogin(HttpServletRequest request, HttpSession session, STU_PASSWD stu_passwd) throws IOException{ String STU_NUM = stu_passwd.getSTU_NUM(); String PASSWD = stu_passwd.getPASSWD(); System.out.println(studentPdService.StudentLogin(STU_NUM,PASSWD)); System.out.println(STU_NUM+PASSWD); ModelAndView mav1 = new ModelAndView(); if(studentPdService.StudentLogin(STU_NUM,PASSWD)!=0){ System.out.println(&quot;成功&quot;); mav1.setViewName(&quot;FirstPageForStudent&quot;); }else{ System.out.println(&quot;失败&quot;); mav1.setViewName(&quot;StudentLoginFailed&quot;); } System.out.println(mav1); return mav1; controller参数是一个学生用户名密码对象，使用getter方法获得参数。注意的一点是，在form表单的input中，name的属性要和javabean中的保持一致，否则获取的参数值是null.]]></content>
      <tags>
        <tag>毕设</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无题]]></title>
    <url>%2F2017%2F10%2F24%2F%E6%97%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;19.1.10.我这般烦恼，你有像我这样忧愁过吗]]></content>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro学习一]]></title>
    <url>%2F2017%2F10%2F13%2Fshiro%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ssm-restful接口]]></title>
    <url>%2F2017%2F10%2F08%2Fssm-restful%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[功能 1.jar包使用maven管理 2.基于ssm+spring boot框架，实现对腾讯云数据库的增删改查。 3.对外提供API接口，接口类型restful。 个人理解在这个项目中，一开始并不知道什么是API接口，查了资料明白了一点。 １.什么是rest? 用URL定位资源，用HTTP描述操作。即就是选择通过使用http协议和uri,利用client/sersver model对资源镜子那个CRUD操作。 2.rest风格的好处？ 客户端服务端分离。 无状态：就是从客户端的每个请求要包含服务器所需要的所有信息。 分层。 项目搭建步骤 step1:使用IDEA搭建一个spring boot项目：file-&gt;new project-&gt;Spring Initializr-&gt;next-&gt;next-&gt;web-&gt;next-&gt;finish。 step2:给新建的项目java文件加设置成源文件。 step3:在pom.xml文件中添加相应的依赖包。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.jin&lt;/groupId&gt; &lt;artifactId&gt;ssm-restful&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;ssm-restful&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--新增所需依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; step4:在application.properties文件中配置数据库以及对象和数据库的映射文件。1234567spring.datasource.url=jdbc:mysql://47.93.221.55:3306/lesson1spring.datasource.username=rootspring.datasource.password=Xt124104spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.jpa.database=mysqlmybatis.mapper-locations=classpath*:mapper/*.xmlmybatis.type-aliases-package=com.jin.ssmrestful.pojo step5:实体类文件：12345678910111213141516171819202122232425262728293031package com.jin.ssmrestful.pojo;public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; step6:接口(以查询所有用户为例)1234567891011121314package com.jin.ssmrestful.mapper;import com.jin.ssmrestful.pojo.User;import org.springframework.stereotype.Repository;import java.util.List;@Repositorypublic interface UserMapper &#123; /*查询所有用户*/ List&lt;User&gt; userList(); &#125; step7:编写UserMapper.xml文件123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;com.jin.ssmrestful.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;com.jin.ssmrestful.pojo.User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;userList&quot; resultMap=&quot;userMap&quot;&gt; select * from user &lt;/select&gt; &lt;/mapper&gt; step8:编写controller.java控制器12345678910111213141516171819202122232425package com.jin.ssmrestful.controller;import com.jin.ssmrestful.mapper.UserMapper;import com.jin.ssmrestful.pojo.User;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.List;/*@RestController注解说明他是一个rest风格的接口，返回json*/@RestControllerpublic class UserController &#123; /*controller控制器中需要注入UserMapper,这里省了service * 层，直接调用接口中的方法*/ @Autowired private UserMapper userMapper; /*查询所有用户*/ @RequestMapping(value = &quot;/ssm-restful/userList&quot;) public List&lt;User&gt; userList()&#123; return userMapper.userList(); &#125;&#125; step9:启动，地址栏输入：localhost:8080/ssm-restful/userList,页面返回的是json串。 总结点： （1）在上面的代码中，UserMapper.java文件中会报错，缺少bean,那么这个地方，我们实际上是少了一个注解，在mapper类名上加1234 （2）在mybatis配置文件中，mapper标签中的namespace属性一定要写。映射文件中的namespace是用于绑定Dao接口的，即面向接口编程。step10：根据id查询用户UserMapper.java文件中添加一个抽象方法 /根据id查询用户/ User findUserById(int id);1classpath下面的mapper目录下面的Usermapper.xml文件中需要添加mabatis的查询误操作 &lt;!--根据id查询用户--&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;User&quot;&gt; select * from user where id = #{id} &lt;/select&gt; 1controller文件找那个添加逻辑处理方法 /*根据id查询用户*/ @RequestMapping(value = &quot;/aliyun/findUserById&quot;,method = RequestMethod.GET) public User findUserById(@Param(&quot;id&quot;) int id){ return userMapper.findUserById(id); } 12启动项目，在地址栏输入你想查询的用户id，例如：localhost:8080/aliyun/findUserById?id=1，浏览器中会返回以Json形式的id为1的用户的信息。**注意**：在处理这个id的时候，我使用的是@Param(&quot;id&quot;)形式的参数绑定，后来换了一种方式：@PathVariable(&quot;id&quot;),仅仅替换了这个是不能成功的，我们还需要在地址映射的url上面添加我们的参数id，所以，完整的第二种方法应该是： /根据id查询用户/ @RequestMapping(value = “/aliyun/findUserById/{id}”,method = RequestMethod.GET) public User findUserById(@PathVariable(“id”) int id){ return userMapper.findUserById(id); }1234在这种方法下，访问时输入的地址也会有所变化，根据@RequestMapping中的value值，我们知道，在访问id为1这个用户的时候，只需要以下形式的输入：localhost:8080/aliyun/findUserById/1step11:新增用户UserMapper.java文件中添加如下代码： /增加用户/ void addUser(String username,String password);1mapper目录下面的UserMapper.xml文件中添加如下代码 &lt;insert id=&quot;addUser&quot; parameterType=&quot;String&quot;&gt; insert into user(username,password) values(#{0},#{1}) &lt;/insert&gt; 1controller控制器中添加如下代码 /增加用户/ @RequestMapping(value = “aliyun/addUser”,method = RequestMethod.GET) public void addUser(@Param(“username”) String username,@Param(“password”) String password){ User user = new User(); user.setUsername(username);; user.setPassword(password); userMapper.addUser(username,password); }1234567 运行测试时输入以下形式的网址：http://localhost:8080/aliyun/addUser?username=jin&amp;password=123456789 在新增用户信息的时候，有两个地方需要注意一下。 （１）mybatis的映射文件中，插入操作写```insert into user(username,password) values(#&#123;username&#125;,#&#123;password&#125;)```这样的方式是不可以的，mybatis不能匹配，正确的方式，是将后面的两个参数分别用0和1 替换。 （2）在controller文件中，我们接受参数的时候使用第一张就不可以了，应该使用@Param()，其次，新增用户的时候，我们必须新建一个用户对象，这时这个对象就拥有username和password属性，将我们新增的用户名和密码分别使用它们的set方法为它们赋值。但是，不新增直接使用```userMapper.addUser(username,password);```也可以。 step12:更新用户UserMapper.java文件中添加如下代码： /更新用户信息/ void updateUser(User user);1mapper目录下面的UserMapper.xml文件中添加如下代码： &lt;update id=&quot;updateUser&quot; parameterType=&quot;User&quot;&gt; update user set username=(#{username}),password=(#{password}) where id = #{id} &lt;/update&gt; 1controller控制器中添加如下代码： /修改用户/ @RequestMapping(value = “/aliyun/updateUser/{id}”,method = RequestMethod.GET) public void updateUser(@PathVariable(“id”) int id,@Param(“username”) String username,@Param(“password”) String password){ User user = new User(); user.setId(id); user.setPassword(password); user.setUsername(username); userMapper.updateUser(user); }12345访问路径如下所示：http://localhost:8080/aliyun/updateUser/1?username=apple1&amp;password=1 修改用户信息和新增类似，controller中都需要新建一个用户，当然，这种方式是在新增的时候以user为参数的前提下，也可以分开来。 step13：根据id删除用户 Usermapper.java文件如下： /根据id删除用户/ void deleteUser(int id);1mapper目录下面的usermapper.xml文件如下： &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt; delete from user where id = #{id} &lt;/delete&gt; 1controller控制器中的代码如下： /*根据id删除用户*/ @RequestMapping(value = &quot;/aliyun/deleteUser/{id}&quot;,method = RequestMethod.GET) public void deleteUser(@PathVariable(&quot;id&quot;) int id){ userMapper.deleteUser(id); } `以上便是所有的功能实现 注意：在写接口名时，接口名和控制器的方法名以及userMapper.xml文件中对应的sql语句的id应该保持一致。 查询所有用户的时候用resultMap返回集合，根据id查询时也是，新增用户和修改用户的时候参数形式是String或者是User。 mapper标签的namespace属性要写上去。namespace用于绑定dao接口，表示面向接口编程。]]></content>
      <tags>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA搭建ssm项目详解]]></title>
    <url>%2F2017%2F10%2F08%2FIDEA%E6%90%AD%E5%BB%BAssm%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[这篇文章主要回顾之前做过的关于ssm项目的过程，顺便复习。 步骤如下 step1:使用IDEA创建一个maven webapp项目，名称为test-ssm。 step2:建立数据库和表,数据库名称how2java,表名category_。 step3:在项目中的pom.xml文件中加入我们需要的依赖文件。这些文件可以在阿里云的maven仓库中找到，地址：http://maven.aliyun.com/nexus/。 pom.xml文件如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;properties&gt; &lt;!-- 设置项目编码编码 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;taglibs&lt;/groupId&gt; &lt;artifactId&gt;standard&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; step4：在项目中的java文件下建立包:cn.itcast.pojo,在这个包中建立类Category.java,这个包中存放项目中需要使用的实体类,该项目的实体类文件如下所示：123456789101112131415161718192021222324252627282930package cn.itcast.pojo;public class Category &#123; private int id; private String name; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;Category&#123;&quot; + &quot;id=&quot; + id + &quot;, name=&apos;&quot; + name + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 实体类中有两个字段id,name,分别实现他们的getter和setter方法以及tostring方法。 step5:在项目的java文件夹下面建立包cn.itcast.mapper，在该包下面建立接口CategoryMapper.java,代码如下：12345678910111213141516171819202122232425package cn.itcast.mapper;import cn.itcast.pojo.Category;import java.util.List;public interface CategoryMapper &#123; /*增加功能*/ public void add(Category category); /*删除功能*/ public void delete(int id); /*根据id查找功能*/ public Category get(int id); /*更新功能*/ public void update(Category category); /*显示所有功能*/ public List&lt;Category&gt; list(); /*显示总记录功能*/ public int count();&#125; step6:在项目的resources文件夹下面建立目录mapper,在这个目录下建立Category.xml文件，这个文件的作用mybatis文件，用于映射实体类和数据库中的字段，并且进行相应的增删改查操作。具体代码如下：12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;cn.itcast.mapper.CategoryMapper&quot;&gt; &lt;insert id=&quot;add&quot; parameterType=&quot;Category&quot; &gt; insert into category_ ( name ) values (#&#123;name&#125;) &lt;/insert&gt; &lt;delete id=&quot;delete&quot; parameterType=&quot;Category&quot; &gt; delete from category_ where id= #&#123;id&#125; &lt;/delete&gt; &lt;select id=&quot;get&quot; parameterType=&quot;_int&quot; resultType=&quot;Category&quot;&gt; select * from category_ where id= #&#123;id&#125; &lt;/select&gt; &lt;update id=&quot;update&quot; parameterType=&quot;Category&quot; &gt; update category_ set name=#&#123;name&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;select id=&quot;list&quot; resultType=&quot;Category&quot;&gt; select * from category_ &lt;/select&gt;&lt;/mapper&gt; step7:在项目的java文件夹下面建立包cn.itcat.service，建立接口CategoryService.java,该层的主要作用是业务层，即真真需要实现的功能。本项目中我们只实现显示所用用户的功能，代码如下：123456789package cn.itcast.service;import cn.itcast.pojo.Category;import java.util.List;public interface CategoryService &#123; List&lt;Category&gt; list();&#125; step8:在第七步建立的service包下建立impl目录，新建CategoryServiceImpl.java文件，这个文件的主要作用是实现之前创建的接口。代码如下:12345678910111213141516171819package cn.itcast.service.impl;import cn.itcast.mapper.CategoryMapper;import cn.itcast.pojo.Category;import cn.itcast.service.CategoryService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class CategoryServiceImpl implements CategoryService &#123; @Autowired private CategoryMapper categoryMapper; public List&lt;Category&gt; list() &#123; return categoryMapper.list(); &#125;&#125; 我们这里使用到了注解，由于是service层，所以我们在类的上面添加注解@Service,这样在项目运行的时候，根据配置扫描到我们的service，在service层需要用到之前创建的接口，我们我们需要注入接口，使用注解： @Autowired。 step9:上面这些都是简单的逻辑实现，下面我们需要进行配置，ssm主要就是要进行配置，首先，我们从项目的web.xml文件开始。先上代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:web=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; version=&quot;2.5&quot;&gt; &lt;!--Spring 配置文件--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 1.首先浏览器上访问路径/listCategory 2.tomcat根据web.xml上的配置信息，拦截到了/listCategory, 并将其交由DispatcherServlet处理 3.DisppatcherServlet根据springMVC的配置，将这次请求交由 CategoryController类处理，所以需要进行这个类的初始化、、 4.在实例化categoryController的时候，注入categoryServiceImpl 5.在实例CategoryServiceImpl的时候，注入 CategoryMapper 6.根据applicationContext.xml文件中的配置信息，将CategoryMapper 和Category.xml文件关联 7.这样拿到了实例化好的 CategoryController，并调用listCategory 方法 8.在listCategory方法中，访问categoryService，并获取数据，并把数据放在 &quot;cs&quot;上，接着服务端调转到listCategory.jsp去 9.最后在litcategory.jsp中显示数据 --&gt; &lt;!--配置springmvc核心过滤器dispathcerservlet--&gt; &lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--spring mvc的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; step10:spring的配置文件applicationContext.xml文件，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=&quot;cn.itcast.service&quot;/&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.DriverManagerDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot;&gt; &lt;value&gt;com.mysql.jdbc.Driver&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt; &lt;value&gt;jdbc:mysql://localhost:3306/how2java&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;user&quot;&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;property name=&quot;password&quot;&gt; &lt;value&gt;root&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;cn.itcast.pojo&quot;&gt;&lt;/property&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapper/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;cn.itcast.mapper&quot;&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; step11:springmvc的配置文件1234567891011121314151617181920212223242526272829&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:jdbc=&quot;http://www.springframework.org/schema/jdbc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd&quot;&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package=&quot;cn.itcast.controller&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;/context:component-scan&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;/&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsp/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; step12:最后是list界面：123456789101112131415161718192021222324&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; %&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table align=&quot;center&quot; border=&quot;1&quot; cellspacing=&quot;0&quot;&gt; &lt;tr&gt; &lt;td&gt;id&lt;/td&gt; &lt;td&gt;name&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;c:forEach items=&quot;$&#123;cs&#125;&quot; var=&quot;c&quot; varStatus=&quot;st&quot;&gt; &lt;tr&gt; &lt;td&gt;$&#123;c.id&#125;&lt;/td&gt; &lt;td&gt;$&#123;c.name&#125;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 完毕。]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis面试题]]></title>
    <url>%2F2017%2F10%2F08%2Fmybatis%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.#{}和${}的区别是什么？ ${}是Properties文件中的变量占位符，它可以用于标签属性值和sql内部，属于静态文本替换，比如${driver}会被静态替换为com.mysql.jdbc.Driver。#{}是sql的参数占位符，Mybatis会将sql中的#{}替换为?号，在sql执行前会使用PreparedStatement的参数设置方法，按序给sql的?号占位符设置参数值，比如ps.setInt(0, parameterValue)，#{item.name}的取值方式为使用反射从参数对象中获取item对象的name属性值，相当于param.getItem().getName()。 2.最佳实践中，通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？ Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个&lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt;标签，都会被解析为一个MappedStatement对象。 Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。 Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。 3.Mybatis的Xml映射文件中，不同的Xml映射文件，id是否可以重复？ 不同的Xml映射文件，如果配置了namespace，那么id可以重复；如果没有配置namespace，那么id不能重复；毕竟namespace不是必须的，只是最佳实践而已。]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springMVC面试题]]></title>
    <url>%2F2017%2F10%2F08%2FspringMVC%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.SpringMVC工作原理： 1.客户端发送请求到DispatcherServlet 2.DispatcherServlet查询handlerMapping找到处理请求的Controller 3.Controller调用业务逻辑后，返回ModelAndView 4.DispatcherServlet查询ModelAndView，找到指定视图 5.视图将结果返回到客户端 ２.SpringMvc的控制器是不是单例模式,如果是,有什么问题,怎么解决？ 是单例模式,所以在多线程访问的时候有线程安全问题,不要用同步,会影响性能的,解决方案是在控制器里面不能写字段。 ３.SpingMvc中的控制器的注解一般用那个,有没有别的注解可以替代？ 一般用@Conntroller注解,表示是表现层,不能用用别的注解代替. ４. @RequestMapping注解用在类上面有什么作用？ 是一个用来处理请求地址映射的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。 ５.怎么样把某个请求映射到特定的方法上面？ 直接在方法上面加上注解@RequestMapping,并且在这个注解里面写上要拦截的路径。 ６.如果在拦截请求中,我想拦截get方式提交的方法,怎么配置？ 可以在@RequestMapping注解里面加上method=RequestMethod.GET。 ７.我想在拦截的方法里面得到从前台传入的参数,怎么得到？ 直接在形参里面声明这个参数就可以,但必须名字和传过来的参数一样。 ８.如果前台有很多个参数传入,并且这些参数都是一个对象的,那么怎么样快速得到这个对象？ 直接在方法中声明这个对象,SpringMvc就自动会把属性赋值到这个对象里面。 ９.SpringMvc中函数的返回值是什么？ 返回值可以有很多类型,有String, ModelAndView,当一般用String比较好。 １０.SpringMVC怎么样设定重定向和转发的？ 在返回值前面加”forward:”就可以让结果转发,譬如”forward:user.do?name=method4” 在返回值前面加”redirect:”就可以让返回值重定向,譬如”redirect:http://www.baidu.com&quot;]]></content>
      <tags>
        <tag>springmvc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring面试题]]></title>
    <url>%2F2017%2F10%2F08%2Fspring%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.什么是Spring？ Spring是一个开源的JavaEE开发框架。Spring框架的核心功能可以应用在任何Java应用程序中，但对JavaEE平台上的Web应用程序有更好的扩展性。Spring框架的目标是使得JavaEE应用程序的开发更加简捷，通过使用POJO为基础的编程模型促进良好的编程风格。 2.Spring有哪些优点？ 轻量级：Spring在大小和透明性方面绝对属于轻量级的，基础版本的Spring框架大约只有2MB。 控制反转(IOC)：Spring使用控制反转技术实现了松耦合。依赖被注入到对象，而不是创建或寻找依赖对象。 面向切面编程(AOP)： Spring支持面向切面编程，同时把应用的业务逻辑与系统的服务分离开来。 3.Spring IoC容器是什么？ SpringIOC负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。 4.Spring中的依赖注入是什么？ 依赖注入作为控制反转(IOC)的一个层面，可以有多种解释方式。在这个概念中，你不用创建对象而只需要描述如何创建它们。你不必通过代码直接的将组件和服务连接在一起，而是通过配置文件说明哪些组件需要什么服务。之后IOC容器负责衔接。 5.有哪些不同类型的IOC(依赖注入)？ 构造器依赖注入：构造器依赖注入在容器触发构造器的时候完成，该构造器有一系列的参数，每个参数代表注入的对象。 Setter方法依赖注入：首先容器会触发一个无参构造函数或无参静态工厂方法实例化对象，之后容器调用bean中的setter方法完成Setter方法依赖注入。 6.你推荐哪种依赖注入？构造器依赖注入还是Setter方法依赖注入？ 可以同时使用两种方式的依赖注入，最好的选择是使用构造器参数实现强制依赖注入，使用setter方法实现可选的依赖关系。 ７.什么是Spring Beans？ Spring Beans是构成Spring应用核心的Java对象。这些对象由Spring IOC容器实例化、组装、管理。这些对象通过容器中配置的元数据创建，例如，使用XML文件中定义的创建。在Spring中创建的beans都是单例的beans。在bean标签中有一个属性为”singleton”,如果设为true，该bean是单例的，如果设为false，该bean是原型bean。Singleton属性默认设置为true。因此，spring框架中所有的bean都默认为单例bean。 8.Spring Bean中定义了什么内容？ Spring Bean中定义了所有的配置元数据，这些配置信息告知容器如何创建它，它的生命周期是什么以及它的依赖关系。 9.如何向Spring 容器提供配置元数据？ XML配置文件、基于注解配置和基于Java的配置。 10.什么是bean自动装配？ Spring容器可以自动配置相互协作beans之间的关联关系。这意味着Spring可以自动配置一个bean和其他协作bean之间的关系，通过检查BeanFactory 的内容里没有使用和&lt; property&gt;元素。 11.解释自动装配的各种模式？ no：默认的方式是不进行自动装配，通过手工设置ref 属性来进行装配bean。 byName：byName就是通过Bean的id或者name byType：通过参数的数据类型自动自动装配，就是按Bean的Class的类型。 12.什么是Spring基于Java的配置？给出一些注解的例子 基于Java的配置允许你使用Java的注解进行Spring的大部分配置而非通过传统的XML文件配置。 以注解@Configuration为例，它用来标记类，说明作为beans的定义，可以被Spring IOC容器使用。另一个例子是@Bean注解，它表示该方法定义的Bean要被注册进Spring应用上下文中 13.@RequestMapping annotation @RequestMapping注解用于将URL映射到任何一个类或者一个特定的处理方法上。 14.@Controller annotation @Controller注解表示该类扮演控制器的角色。Spring不需要继承任何控制器基类或应用Servlet API。 15.什么是Spring的MVC框架？ Spring提供了一个功能齐全的MVC框架用于构建Web应用程序。Spring框架可以很容易的和其他的MVC框架融合(如Struts)，该框架使用控制反转(IOC)将控制器逻辑和业务对象分离开来。它也允许以声明的方式绑定请求参数到业务对象上。 16.DispatcherServlet Spring的MVC框架围绕DispatcherServlet来设计的，它用来处理所有的HTTP请求和响应。]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试基础2]]></title>
    <url>%2F2017%2F10%2F06%2Fjava%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%802%2F</url>
    <content type="text"><![CDATA[1、面向对象的特征有哪些方面 1.抽象： 抽象就是忽略一个主题中与当前目标无关的那些方面，以便更充分地注意与当前目标有关的方面。抽象并不打算了解全部问题，而只是选择其中的一部分，暂时不用部分细节。抽象包括两个方面，一是过程抽象，二是数据抽象。 2.继承： 继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表述共性的方法。对象的一个新类可以从现有的类中派生，这个过程称为类继承。新类继承了原始类的特性，新类称为原始类的派生类（子类），而原始类称为新类的基类（父类）。派生类可以从它的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更适合特殊的需要。 3.封装： 封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治、封装的对象，这些对象通过一个受保护的接口访问其他对象。 4. 多态性： 多态性是指允许不同类的对象对同一消息作出响应。多态性包括参数化多态性和包含多态性。多态性语言具有灵活、抽象、行为共享、代码共享的优势，很好的解决了应用程序函数同名问题。 ２.一个”.java”源文件中是否可以包括多个类（不是内部类）？有什么限制？ 可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。 ３.JDK是什么？JRE是什么？ JDK：java开发工具包。JRE：java运行时环境。 ４. 什么是java的平台无关性？ Java源文件被编译成字节码的形式，无论在什么系统环境下，只要有java虚拟机就能运行这个字节码文件。也就是一处编写，处处运行。这就是java的跨平台性。 ５. 在一台电脑上配置java环境，path起什么作用？如何配置？ path的作用是在DOS环境下，能在任意位置使用JDK目录中bin文件夹中的可执行程序，来编译执行java程序。 ６. &amp;&amp;和&amp;区别，||和|区别？ &amp;&amp;和||是短路与，短路或，当左边的表达式能判断当前结果，则不判断右边的表表达式。 而&amp; 和|则将两边的表达式都运算完毕后，再算结果 ７.break与continue,return结束循环区别？ break语句使用场合主要是switch语句和循环结构。switch中，直接退出循环，执行循环结构下面的第一条语句。在多重嵌套循环中使用break语句，当执行break语句时，退出的是它所在的循环结构，对外层循环没有影响。 continue语句可以理解为继续循环不执行下面的语句。continue语句并没有真的退出循环，而是只结束本次循环的执行。 return跳出整个函数体，函数体后面的部分不再执行。 解释什么是类的成员变量，局部变量，实例成员变量，类成员变量？ 类的变量定义部分所定义的变量被称为类的成员变量。类中方法外。 在方法体中定义的变量和方法的参数被称为局部变量。 成员变量又分为实例成员变量和类成员变量（static修饰）。 ９.this和super关键字用法。 在Java中，this通常指当前对象，super则指父类的。当想要引用当前对象的某种东西，比如当前对象的某个方法，或当前对象的某个成员，便可以利用this来实现这个目的，当然，this的另一个用途是调用当前对象的另一个构造函数。如果想引用父类的某种东西，则非super莫属。 １.在一般方法中 最普遍的情况就是，在我们的方法中的某个形参名与当前对象的某个成员有相同的名字，这时为了不至于混淆，我们便需要明确使用this关键字来指明你要使用某 个成员，使用方法是“this.成员名”，而不带this的那个便是形参。另外，还可以用“this.方法名”来引用当前对象的某个方法，但这时this就不是必须的了，我们可以直接用方法名来访问那个方法，编译器会知道我们要调用的是那一个。 ２.在构造函数中 在构造函数中，super后加参数的是用来调用父类中具有相同形式的构造函数，this后加参数则调用的是当前具有相同参数的构造函数。 总之，this通常指代当前对象，super通常指代父类。 10.什么是构造方法？ 构造方法是一种特殊方法，它的名字必须与它所在的类的名字完全相同，作用是对类进行初始化。 系统什么情况下会为类提供构造方法，提供什么样的构造方法？ 如果类中没有构造方法，系统会提供一个默认的构造方法，默认的构造方法是无参的。 类变量有什么特点？ 一个类的所有对象共享同一个类变量。 类方法有什么特点？ 同一类中，类方法只能调用类变量和类方法。 简述super关键字作用？ 使用super调用父类的构造方法。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java反射]]></title>
    <url>%2F2017%2F09%2F28%2Fjava%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[#认识Class类**1.java语言中，万事万物皆对象。那么这些对象又是谁的对象呢？我们可以这样理解，每一个我们创建的类都是对象，他们都是java.lang.Class的实例对象。 2.任何一个类都是Class类的实例对象，这个实例对象又三种表示方式。(1)方式112//第一种表示方式--》实际上告诉我们，任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; (2)方式212//第二种 已知该类的对象，通过getClass方法 Class c2 = foo.getClass(); (3)方式312345678//第三种表示 Class c3 = null; try &#123; c3 = Class.forName(&quot;com.imooc.reflect.Foo&quot;); System.out.println(c2==c3); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; 要点1：12//不管是c1还是c2都代表了Foo类的类类型，一个类只可能是Class的一个实例对象,上面的c3其实和c1,c2都是一个对象 System.out.println(c1==c2); 3.12345678910/*我们完全可以通过类的类类型创建该类的对象实例 * 通过c1,c2或者是c3创建Foo类的实例对象 */ try &#123; Foo foo1 = (Foo)c1.newInstance(); foo.print(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; 4.完整代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152package com.imooc.reflect;public class ClassDemo1 &#123; public static void main(String[] args) &#123; //Foo的实例对象如何表示 Foo foo = new Foo(); //Foo这个类本身也是一个实例对象，他是Class类的实例对象，如何表示呢？ //任何一个类都是Class类的实例对象，这个实例对象又三种表示方式 //第一种表示方式--》实际上告诉我们，任何一个类都有一个隐含的静态成员变量class Class c1 = Foo.class; //第二种 已知该类的对象，通过getClass方法 Class c2 = foo.getClass(); //c1,c2表示了Foo类的类类型 /*万事万物皆对象， 类也是对象，是Class类的实例对象 这个对象我们称之为该类的类类型 */ //不管是c1还是c2都代表了Foo类的类类型，一个类只可能是Class的一个实例对象 System.out.println(c1==c2); //第三种表示 Class c3 = null; try &#123; c3 = Class.forName(&quot;com.imooc.reflect.Foo&quot;); System.out.println(c2==c3); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; /*我们完全可以通过类的类类型创建该类的对象实例 * 通过c1,c2或者是c3创建Foo类的实例对象 */ try &#123; Foo foo1 = (Foo)c1.newInstance(); foo.print(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class Foo&#123; public void print()&#123; System.out.println(&quot;Class&quot;); &#125;&#125; #动态加载类1.Class.forName(“类的全称”) .不仅表示了类的类类型，还代表了动态加载类 .区分编译和运行，编译时刻加载类是静态加载类，运行时刻加载类是动态加载类。 2.例：12345678910111213class Office&#123; public static void main(String[] args)&#123; if(&quot;Word&quot;.equals(args[0]))&#123; //new 对象是静态加载类，在编译时刻就需要加载所有的可能使用到的类 Word w = new Word(); w.start(); &#125; if(&quot;Excel&quot;.equals(args[0]))&#123; Excel e = new Excel(); e.start(); &#125; &#125;&#125; 我们创建了一个Office类，当我们需要编译运行Word类的时候就在窗口中输入javac Word.java,当我们需要编译运行Excel类的时候，我们就在窗口中输入javac Excel.java,但是，在这个程序中，第一步，当我们编译运行 javac Office.java的时候，会报告四个错误，没有找到word和Excel类，这个时候我们创建一个Word类12345class Word&#123; public static void start()&#123; System.out.println(&quot;word...starts&quot;); &#125;&#125; 再次编译运行Office.java ,系统报告了两个错误，没有Excel类，那么在这个地方，当我们在运行这个程序的时候，我们必须要要保证两个类事先都必须存在，有一个类不存在，其他不管多少个类都不能够使用。这样new出来的对象在编译时刻必须加载所有的类的情况就叫静态加载类的过程。能不能有这样一种情况，当我们需要编译运行Word类的时候，我们输入javac Word.java ，程序自动为我们加载需要的Word类，其他不需要的了都不用加载？这样在运行时刻加载类的过程叫动态加载类。 3.什么是java的反射机制？ 就是可以在程序运行的时候动态装载类，查看类的信息，生成对象，或操作生成对象。类在运行的时候，可以得到该类的信息，并且 可以动态的修改这些信息，自己能看到自己，跟照镜子一样，也就是说Java的反射机制是在编辑的时候并不确定哪个类被加载了，而是在程序运行的时候才加载、探知、自审，使用在编译期并不知道的类，这样的特点就是反射。 ４.java的反射机制的作用？ 假如我们有两个程序员，一个程序员在写程序的时候，需要使用第二个程序员所写的类，但第二个程序员并没完成他所写的类。那么第一个程序员的代码能否通过编译呢？这是不能通过编译的。利用Java反射的机制，就可以让第一个程序员在没有得到第二个程序员所写的类的时候，来完成自身代码的编译。Java反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java后端面试]]></title>
    <url>%2F2017%2F09%2F28%2Fjava%E5%90%8E%E7%AB%AF%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[1.SpringMVC有哪些常用注解？ @Controller（控制层）、@Service（业务层）、@RequestMapping（控制层，访问路径），@Autowired、@Resouce、@ResponseBody。 2.如何获取在@RequestMapping注解中定义的变量？ 这个在RESTFul风格中比较常见，在方法的参数中再加@PathVariable(“var”)参数即可。 ３.如何在Controller中获取request请求的变量，非RESTFul那种拼接的参数？ 可以直接在方法参数中，添加HttpServletRequest参数变量就行，然后根据req的getParameter(“var”)获取相应的参数。]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java面试基础部分]]></title>
    <url>%2F2017%2F09%2F27%2Fjava%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%801%2F</url>
    <content type="text"><![CDATA[1.String类是最基本的数据类型吗？ 不是。java中的基本数据类型只有８个：byte、short、int、long、float、double、char、boolean。String是一个类，但是被final修饰，不能被继承。 2.int和Integer的区别？ int是基本的数据类型，而Integer是int的封装类型，Integer可以调用方法，int不可以。基本数据类型有自动拆箱和自动装箱的功能，jdk1.5之后提供。 （1）当我们创建Integer对象的时候，可以这样创建： Integer i = 100; 这里的i是一个对象，是可以调用方法的，他的创建方式并不像我们平常创建对象的方式，其实在执行这句话的时候，系统自动为我们执行了：Integer i Integer.valueOf(100);这个就是基本数据类型的自动装箱功能。 （2）什么时候自动装箱？ 像上面那条语句一样，执行Integer i = 100；系统会自动装箱Integer i Integer.valueOf(100); （3）什么时候自动拆箱？ Integer i = 10;//装箱 int j = i;//拆箱，实际执行了int t = i.intValue(); 3.String、StringBuffer、StringBuilder之间的区别。 （1）在执行速度方面Stirng BUilder&gt;StringBuffer&gt;String （2）String速度小于其他两者的原因： String：字符串敞亮 StringBuffer、StringBuilder字符串变量。 对于下面的语句： Stirng s = aaa”; s = s+1; System.out.println(s);//aaa1 既然String是字符串常量，为什么后面还是可以改变值呢？其实，在JVM中是这样解析这段代码的： 首先创建一个对象s，然后再创建一个对象s来执行第二段代码，也就是说我们之前创建的那个String s值并没有变。基于这种机制，对String类型操作的时候，其实就是在不断的创建对象，执行效率当然会很低。而另外两者是字符串变量，当对他们执行字符操作的时候，实际都是在一个对象上操作。速度自然比较快。 一个特殊的例子： String s = “a”+”b”+”c”; 在执行这条语句的时候速度比之前的那种方式要快,这时为什么呢？其实，这条语句的本质还是 String s = “abc”； 但是，如果a,b,c是分别创建的话，速度就没有那么快。 String s1 = “a”; String s2 = “b”; String s3 = “c”; 这样的方式JVM还是会按照之前的方式去操作。 （3）StringBuilder和StringBuffer 前者是线程不安全的，后者是线程安全的。 4.重载Overload和重写Override的区别。重载的方法能否根据返回类型区分？ 方法重载和方法重写都是实现多态的方式。重载发生在一个类中，同名的方法有不同的参数列表（参数类型不同、参数个数不同或者两者都不同），重载的返回值类型必须相同；重写发生在子类和父类之间，子类中有和父类相同的方法。重写的规则如下： 参数列表和父类相同，返回类型相同，访问修饰符限制大于父类。 4.抽象类（abstract class）和接口(interface)异同 同：（１）抽象类和接口都不能被实例化，但可以定义抽象类和接口类型的引用 （２）一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的凑向方法全部进行实现，否则该类仍然被称为抽象类。 异：接口比抽象类更加抽象，因为抽象类可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且方法必须全部是抽象方法。 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的。 ５.阐述静态变量和实例变量的区别。 语法区别：静态变量是需要static关键字修饰的，实例变量不需要。 程序运行时区别：实例变量属于对象，必须创建实例对象其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某一个实例变量，属于类，也称其为类变量，只要类被加载，不用创建任何实例对象，静态变量就会被分配空间，并可以使用。 实例变量必须创建对象后通过这个对象来引用，静态变量可以直接使用类名来引用。 ６.final关键字的用法： （１）修饰类：表示该类不能被继承； （2）修饰方法:表示该方法不能被重写； （3）修饰变量：表示变量只能一次赋值以后不能被修改。 Error和Exception有什么区别？ Error表示系统级的错误，不可能指望程序能处理这样的情况；Exception表示需要捕捉或者需要程序进行处理的异常，是一种设计或者实现问题，也就是说，他表示如果程序运行正常，从不会发生的情况。 8.列出一些常见的运行异常？ ArithmeticException(算术异常) ClassCastException(类转换异常) IllegalArgumentException(非法参数异常) InedxOutOfBoundsException(下标越界异常) NullPointerException(空指针异常) ９.List、set、Map是否继承自Collection接口? List和set继承Collection接口，Map不是。Map是键值对映射容器，List是线性结构的容器，适用于按照数值索引访问元素的情形。set存贮零散的元素且不允许有重复。 10.简述java的集合框架 Set、List、Map可以看做集合的三大类。Set和List继承自Collection接口。 List集合是有序集合，集合中的元素可以重复，访问集合中的元素可以根据元素的索引来访问。List集合下面有三个子类，他们的特点如下：（1）ArrayList:底层是数组，查询快，增删慢，线程不安全，效率高。（2）Vector：底层数据结构是数组，查询快，增删慢。线程安全，效率低。（3）LinkedList：底层数据结构是链表，查询慢，增删快。线程不安全，效率高。 Set集合是无序集合，集合中的元素不可以重复，访问集合中的元素只能根据元素本身来访问。 Map集合中保存key-value键值对的形式的元素，访问时只能根据没想元素的key来访问其value。 11.对于List集合，为什么基于数组的增删慢，基于链表的增删快？ １.数组将元素在内存中连续存放，每个元素占用相同的内存，如果在数组中增加一个元素，需要大量移动元素，在内存中空出一个元素的空间，然后将要增加的元素放在这个空间。删同理。 ２.链表在内存中是不按照顺序存放的，而是通过指针将他们联系在一起。上一个元素通过指针指向下一个元素。在删除元素时，只需要修改指针就可以。 12.集合方法Collection:(List、Set) （1）add() 添加元素 （2）remove() 删除元素 （3）iterator()迭代器 （4）size() 返回此Collection中的元素数。 Iterator接口：hasNext() 如果仍有元素可以迭代，则返回true next(): 返回迭代的下一个元素。 Iterator遍历: 1234 Iterator it = coll.iterator(); while(it.hasNext()) &#123; System.out.print(it.next() + &quot; &quot;); &#125; Map： put(key,value); 13.你在那些地方使用到xml数据交换和信息配置。前者目前可以被json取代，后者主要应用于框架的配置信息中。 14.什么是DAO模式？Date Access Object 顾名思义是一个为数据库或者其他持久化机制提供抽象接口的对象。在不暴露持久化方案实现细节的前提下提供各种数据访问操作。在实际的开发中，应该将所有对数据的访问操作进行抽象后封装在一个公共的API中。用程序设计语言来说，就是建立一个接口，接口中定义了此应用程序中将会用到的所有的事务方法。在这个应用程序中，当需要和数据源进行交互的时候则使用这个接口，并且编写一个单独的类来实现这个接口，在逻辑上该类对应一个特定的数据存储。 15.什么是ORM? 对象关系映射（Obejct-Relational Mapping）是一种为了解决程序的面向对象模型与数据库的关系模型互不匹配问题的技术；简单的说，ORM是通过使用描述对象和数据库之间映射的元数据（在java中可以用xml或者是注解），将程序中的对象自动持久化到关系数据库中或者将关系数据库表中的行转换成java对象，其本质就是将数据从一种形式转换成另外一种形式。 16.MyBatis中使用#和$书写占位符有什么区别？ #将传入的数据都当成一个字符串，会对传入的数据自动加上引号；$将传入的数据直接显示生成在SQL中。注意：使用$占位符可能会导致SQL注射攻击，能用#的地方就不要使用$，写order by子句的时候应该用$而不是#。 17.解释一下MyBatis中命名空间（namespace）的作用。 在大型项目中，可能存在大量的SQL语句，这时候为每个SQL语句起一个唯一的标识（ID）就变得并不容易了。为了解决这个问题，在MyBatis中，可以为每个映射文件起一个唯一的命名空间，这样定义在这个映射文件中的每个SQL语句就成了定义在这个命名空间中的一个ID。只要我们能够保证每个命名空间中这个ID是唯一的，即使在不同映射文件中的语句ID相同，也不会再产生冲突了。 18.什么是IoC和DI？DI是如何实现的? IOC（控制反转）：全称为：Inverse of Control。从字面上理解就是控制反转了，将对在自身对象中的一个内置对象的控制反转，反转后不再由自己本身的对象进行控制这个内置对象的创建，而是由第三方系统去控制这个内置对象的创建。简单来说就是把本来在类内部控制的对象，反转到类外部进行创建后注入，不再由类本身进行控制，这就是IOC的本质。 DI（依赖注入）：全称为Dependency Injection，意思自身对象中的内置对象是通过注入的方式进行创建。 IOC就是一种软件设计思想，DI是这种软件设计思想的一个实现。 19.什么是springmvc，它与spring有什么关系 springmvc属于spring框架的后续产品，用在基于MVC的表现层开发。 20.springMVC工作流程 （１）客户端发出http请求，只要请求形式符合wen.xml文件配置的*.action就由DispatcherServerlet来处理。 （2）DispatcherServerlet再将请求委托给映射器的对象来讲http请求交给对应的Action来处理。 （3）映射器根据http请求，对比springmvc.xml文件中配置的&lt;bean name = &quot;/hello.action&quot; class=&quot;...&quot;&gt;,如果匹配，再将http请求交给我们书写的controller方法 （4）执行controller中的方法，最终返回一个名叫ModelAndView的对象，其中封装了向视图发送的数据和视图的逻辑名。 （5）ModelAndView对象随着响应到DisPatcherServlet中。 （6）这时DispatcherServerlet接受到了ModelAndView对象，但是他并不知道视图逻辑名是何意，有得委托一个名叫视图解析器的对象去解析ModelAndView对象中的内容。 （7）将视图解析后的内容，再交由DispatcherServerlet核心控制器，DispatcherServerlet将请求转发到具体的jsp页面，取出数据，再显示给用户。 21.int、byte、char各占几个位？ （注意这里说的不是字节，问的是bit位。） int占四个字节，byte一个字节，char2个字节，每个字节占8位，所以int32位，byte8 位，char16位。 22.一个List集合如何不再添加重复的元素进去？ 在添加的时候，通过if(!lsit.contains())进行判断就行了 23.如何判断两个对象是相同的？ 重写类的equals()和hashCode()方法即可，因为其底层就是通过equals()进行比较的 。 重写equals()方法，为什么还要重写hashCode()方法呢？如果我们对一个对象重写了euqals，意思是只要对象的成员变量值都相等那么euqals就等于true，但不重写hashcode，那么我们再new一个新的对象，当原对象.equals（新对象）等于true时，两者的hashcode却是不一样的，由此将产生了理解的不一致，如在存储散列集合时（如Set类），将会存储了两个值一样的对象，导致混淆，因此，就也需要重写hashcode()。 24.为什么需要重写hashCode()方法和equals()方法？ Java中的超类Object类中定义的equals()方法是用来比较两个引用所指向的对象的内存地址是否一致。Java的API文档对Object类的hashCode()方法做了详细的说明，这也是我们重写hashCode()方法时的原则【Object类】。 a.在java应用程序运行时，无论何时多次调用同一个对象时的hsahCode()方法，这个对象的hashCode()方法的返回值必须是相同的一个int值 b.如果两个对象equals()返回值为true,则他们的hashCode()也必须返回相同的int值 c.如果两个对象equals()返回值为false,则他们的hashCode()返回值也必须不同 我们在定义类时，我们经常会希望两个不同对象的某些属性值相同时就认为他们相同，所以我们要重写equals()方法，按照原则，我们重写了equals()方法，也要重写hashCode()方法，要保证上面所述的b,c原则。 当我们自定义的一个类，想要把它的实例保存在集合中时，我们就需要重写这两个方法；集合(Collection)有两个类，一个是List,一个是SetList:集合中的元素是有序的，可以重复的Set:无序，不可重复的以HashSet来说明：HashSet存放元素时，根据元素的hashCode值快速找到要存储的位置，如果这个位置有元素，两个对象通过equals()比较，如果返回值为true,则不放入；如果返回值为false,则这个时候会以链表的形式在同一个位置上存放两个元素，这会使得HashSet的性能降低，因为不能快速定位了。还有一种情况就是两个对象的hashCode()返回值不同，但是equals()返回true,这个时候HashSet会把这两个对象都存进去，这就和Set集合不重复的规则相悖了;所以，我们重写了equals()方法时，要按照b,c规则重写hashCode()方法！]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java中对象和对象引用]]></title>
    <url>%2F2017%2F09%2F27%2Fjava%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[对于java的基础知识一直保持在模糊的状态，这几天想着去试一试学校的面试，所有回顾一下以往学过的知识点，做一下总结。 先定义一个简单的类：1234 public class Student( int id; String name; ) 我们创建一个对象：Student s = new Student(); 上面创建对象的语句实际包含可四个动作： （１）new Student,是以Student为模本在堆内存中创建的一个对象。 （２）末尾的()表示在创建好对象后立即调用Student类的构造方法对刚才生成的类进行初始化。 （３）左边的Student s 创建了一个Student类引用变量，引用变量用于指向之前创建的对象。 （４）“=”操作符使对象引用指向刚刚创建的那个对象。 我们可以将这条语句拆分成两个部分： Student s； s = new Student（）； 上面包含两个部分，一个是对象的引用另一个是对象。对象创建在堆内存中，与创建在栈空间的对象引用等实体不同，对象确确实实存在，但是看不见。 接下来我们再创建一个对象引用 Student s1; 这句话和上面的Student s 一样都在栈空间创建了一个对象的引用，但是上面那个对象引用后来指向了一个具体的对象，而s1还没有指向某一具体的对象，这时他的值为null，我们可以向上面s对象引用那样为s确定指向。 s = new Student(); 这里需要注意的是:s指向的对象和s1指向的对象并不是同一个。适用下面的语句可以将两者指向同一个对象： s = s1; 以上的讨论中，我们可以得出，对象的引用值可以为null，也可以为某一个具体的对象，即一个对象的引用可以指向0个或一个对象，一个对象可以有n个对象引用指向他。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题及解决方法]]></title>
    <url>%2F2017%2F09%2F25%2F%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1.HTML去掉frameset的边框： 设置frameset的属性frameborder=”no”便可去除边框 2.在删除图书的功能模块中，首先点击删除图书，我需要给管理员展示所有的书，这个模块调用了之前ontroller中的allbook.action,问题是点击按钮的时候如何获取图书的id？在button的按钮区域如何获取之前中已经遍历过的ID？方法如下：给button按钮添加onclick事件，参数是book.id,这里就是说遍历书的ID不用再上面中，将ID作为onclick的形参来遍历，便可以将ID传递到controller中 3.接上面的问题，在controller中接受参数的时候，request.getparameter(“id”)类型是string 的，那么如何将string 类型转换成id类型的？解决方法如下： Integer.parseInt(id)]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm中的ajax验证用户名并提交]]></title>
    <url>%2F2017%2F09%2F24%2Fssm%E4%B8%AD%E7%9A%84ajax%E9%AA%8C%E8%AF%81%E7%94%A8%E6%88%B7%E5%90%8D%E5%B9%B6%E6%8F%90%E4%BA%A4%2F</url>
    <content type="text"><![CDATA[以下是代码，我已经被这个问题折腾麻木了。准备工作，关于ssm的各种配置就不用说了，之前已经配置好了额。 注册有两个字段：username,password,表中id自增，主键。 分割线--------------------------------------------------------- 1.pojo包下建立user.java实体类。12345678910111213141516171819202122232425262728293031package cn.edu.aust.pojo;public class User &#123; private int id; private String username; private String password; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; ２.接口mapper包下建立UserMapper.java接口1234567891011121314151617package cn.edu.aust.mapper;import cn.edu.aust.pojo.User;import org.apache.ibatis.annotations.Param;public interface UserMapper &#123; /* * * 登录使用到的查询用户名是否被占用功能*/ int selectUsername(String username); /* * 用户名没有被占用，则将注册的username和password插入数据库 * */ void userAdd(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password);&#125; ３.service包下面建立业务逻辑层的UserService12345678910111213141516package cn.edu.aust.service;import cn.edu.aust.pojo.User;public interface UserService &#123; /* * 登录使用到的查询用户名是否被占用功能 * */ int selectUsername(String username); /* * 用户名没有被占用，则将注册的username和password插入数据库 */ void userAdd(String username,String password);&#125; ４.service.impl包下建立业务逻辑层的实现类：UserServiceImpl.java123456789101112131415161718192021package cn.edu.aust.service.impl;import cn.edu.aust.mapper.UserMapper;import cn.edu.aust.pojo.User;import cn.edu.aust.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; public int selectUsername(String username) &#123; return userMapper.selectUsername(username); &#125; public void userAdd(String username, String password) &#123; userMapper.userAdd(username,password); &#125;&#125; 在service 的实现类中，我们要注入service和接口mapper。 ５.controller包下面建立UserController.java123456789101112131415161718192021222324252627282930313233343536373839404142434445package cn.edu.aust.controller;import cn.edu.aust.pojo.User;import cn.edu.aust.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;@Controller@RequestMapping(&quot;&quot;)public class UserController &#123; @Autowired private UserService userService; @RequestMapping(value=&quot;selectUsername&quot;) public void selectUsername(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String username = request.getParameter(&quot;username&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); if(userService.selectUsername(username)!=0)&#123; response.getWriter().write(&quot;&lt;font color=&apos;red&apos;&gt;用户名不可用&lt;/font&gt;&quot;); &#125;else&#123; response.getWriter().write(&quot;&lt;font color=&apos;green&apos;&gt;用户名可用&lt;/font&gt;&quot;); /* while(password!=null)&#123; userService.userAdd(username,password); &#125;*/ &#125; response.getWriter().flush(); &#125; @RequestMapping(value=&quot;userAdd&quot;) public void userAdd(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(username+password); response.setContentType(&quot;text/html;charset=UTF-8&quot;); userService.userAdd(username,password); &#125;&#125; 6.展示一下我的jsp页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;div class=&quot;signinpanel&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-sm-7&quot;&gt; &lt;div class=&quot;signin-info&quot;&gt; &lt;div class=&quot;logopanel m-b&quot;&gt; &lt;/div&gt; &lt;div class=&quot;m-b&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-sm-5&quot;&gt; &lt;form method=&quot;post&quot; action=&quot;$&#123;pageContext.request.contextPath&#125;/#&quot;&gt; &lt;p class=&quot;m-t-md&quot;&gt;注册图书管理系统&lt;/p&gt; &lt;input type=&quot;text&quot; class=&quot;form-control uname&quot; id=&quot;username&quot; id=&quot;accountName&quot; onblur=&quot;checkUserName()&quot; placeholder=&quot;用户名&quot;/&gt;&lt;span id=&quot;userspan&quot;&gt;&lt;/span&gt; &lt;input type=&quot;text&quot; class=&quot;form-control pword m-b&quot; id=&quot;password&quot; onblur=&quot;userAdd()&quot; placeholder=&quot;密码&quot;/&gt; &lt;button class=&quot;btn btn-success btn-block&quot;&gt;注册&lt;/button&gt;&lt;br/&gt; &lt;strong&gt;已有账号？ &lt;a href=&quot;login.jsp&quot;&gt;立即登录&amp;raquo;&lt;/a&gt;&lt;/strong&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;signup-footer&quot;&gt; &lt;div class=&quot;pull-left&quot;&gt; &amp;copy;jin &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;script&gt; function checkUserName()&#123; if(this.value==&quot;&quot;) &#123; alert(&quot;请输入用户名!&quot;); this.focus(); &#125; var username = document.getElementById(&quot;username&quot;).value; //发出已补请求 //1/得到xhr对象 var xhr = new XMLHttpRequest(); //2.注册状态变化监听器 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; document.getElementById(&quot;userspan&quot;).innerHTML = xhr.responseText; &#125; &#125; &#125; //3.建立与服务器的连接 xhr.open(&quot;GET&quot;,&quot;$&#123;pageContext.request.contextPath&#125;/selectUsername.action?time=&quot;+new Date().getTime+&quot;&amp;username=&quot;+username+&quot;&amp;password=&quot;+password,true); //4.向服务器发出请求 xhr.send(null); &#125; function userAdd() &#123; var username = document.getElementById(&quot;username&quot;).value; var password = document.getElementById(&quot;password&quot;).value; alert(username+password); var xhr = new XMLHttpRequest(); //2.注册状态变化监听器 xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4) &#123; if (xhr.status == 200) &#123; &#125; &#125; &#125; //3.建立与服务器的连接 xhr.open(&quot;GET&quot;,&quot;$&#123;pageContext.request.contextPath&#125;/userAdd.action?&amp;username=&quot;+username+&quot;&amp;password=&quot;+password,true); //4.向服务器发出请求 xhr.send(null); &#125;&lt;/script&gt; ７.UserMapper.xml文件123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot; &gt;&lt;mapper namespace=&quot;cn.edu.aust.mapper.UserMapper&quot;&gt; &lt;resultMap id=&quot;userMap&quot; type=&quot;cn.edu.aust.pojo.User&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;result property=&quot;username&quot; column=&quot;username&quot;/&gt; &lt;result property=&quot;password&quot; column=&quot;password&quot; /&gt; &lt;/resultMap&gt; &lt;!--注册验证用户名是否被占用--&gt; &lt;select id=&quot;selectUsername&quot; resultType=&quot;int&quot;&gt; select count(*) from user where username= #&#123;username&#125; &lt;/select&gt; &lt;!--注册时用户名可以使用，则往数据库插入一条记录--&gt; &lt;insert id=&quot;userAdd&quot; parameterType=&quot;String&quot;&gt; insert into user(username,password) values(#&#123;username&#125;,#&#123;password&#125;) &lt;/insert&gt;&lt;/mapper&gt; 在写验证的过程中，第一个问题查询问题:查询用户名是否存在：Invalid bound statement (not found)：自己对mybatis知识点了解不熟，在这个问题上我之前也遇到同样的问题，原因是我的select的id名称和方法名不一致。 在验证成功后，用户名可以注册，那么如何插入到数据库中呢，我的下意识是在验证成功后直接插入，get请求传递参数时，将用户填写的password参数也一起传递过来，然而没有用，password值为null,于是我为 password框也添加了一个onnlur事件，函数名和username的一样，这次插入的时候仅仅只能插入uesrname，controller方法中可以接受到password,password不能插入，这是为什么呢？后来一想，当我输入完username 的时候，onblur事件立即就执行了，同时执行插入操作。这个时候password 还，有接受到。 修改后的代码如上所示，首先为username添加onblur事件执行验证操作，在password输入完成后添加onblur事件执行插入操作。成功。]]></content>
      <tags>
        <tag>ssm ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库中如何保存图片]]></title>
    <url>%2F2017%2F09%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[1.貌似学了很多东西，但是都零零散散，前一个星期想着应该做点什么出来，把自己学到的东西都应用在上面。 2.开发环境：工具IDEA+ssm+maven+ajax+bootstrap 3.开始我的想法是将图片直接存在数据库中，可是不知道怎么存，网上搜了一个在我看起来比较简单的方法：在数据库中存入图片路径。以下是我遇到的一些问题以及后来的解决方案。 （1）路径该如何写?我是在webapp下面建立了一个images目录，所有图片都存在这个目录下，数据库中的路径应该写相对路径”images/1.png”，这个问题我没有遇到，但是网上好多人都写错了。 (2)在查询所有书目的时候，有的书图片可以显示，有的不可以（显示的都是英文名的图片），折腾了好久以为自己存入的路径什么的有问题，但是其他的又可以显示，后来发现了只有英文名可以显示，是否是路径编码的问题？尝试着改变了一下tomcat的编码，成功的解决了我的问题。 解决方法如下：到tomcat的目录下找conf目录——&gt;打开server.xml，将文件的71行开始内容改成如下：123 &lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot;connectionTimeout=&quot;20000&quot;redirectPort=&quot;8443&quot; URIEncoding=&quot;UTF-8&quot;/&gt; 即我们添加了URIEncoding=”UTF-8”这句话，使URI编码成utf-8的格式，支持中文路径。 (3)最最重要的一点：保存图片路径时，小心谨慎，不要写错图片名字，我因为这个问题白白浪费了好久的时间。]]></content>
      <tags>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootStrap学习1]]></title>
    <url>%2F2017%2F09%2F20%2FbootStrap%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[1.引入bootstrap的步骤： rel12&lt;script src=&quot;jquery/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;bootstrap-3.3.7-dist/js/bootstrap.js&quot;&gt;&lt;/script&gt; 按照上面的代码，我们在引入bootstrap的jar包时必须按照一定的顺序，首先css样式，再是我们单独下载的jquery的jar包，然后是bootstrap的js包。]]></content>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js复习]]></title>
    <url>%2F2017%2F09%2F19%2Fjs%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[#1.js中构造函数的三种方式 1.正常方式：1234function add(num1,num2) &#123; return num1+num2; &#125; window.alert(add(1,2)); 2.构造器方式：12var add2 = new Function(&quot;num1&quot;,&quot;num2&quot;,&quot;return num1+num2&quot;); window.alert(add(1,3)); Function括号中最后一个双引号里面代表的是函数体，前面的字符串代表的是函数的参数。 匿名函数:1234var add = function (a,b) &#123; return a+b; &#125; window.alert(add(3,4)); #2.js中的对象1.Date12var nowstr = new Date().toLocaleString(); document.write(nowstr); 2.Math123for(var i=1;i&lt;10;i++)&#123; document.write(Math.floor(Math.random()*9+1)+&quot;&lt;br/&gt;&quot;); &#125; 3.String12var str = &quot;hello你好&quot;; alert(str.length); 4.array12345var array = new Array(&quot;1&quot;,&quot;2&quot;); for(var i=0;i&lt;array.length;i++) alert(array[i]); //document.write(array[i]+&quot; &quot;); &#125; 5.自定义对象123456789function Person(id,name,sal) &#123; this.id = id; this.name = name; this.sal = sal;&#125;var p = new Person(1,&quot;haha&quot;,20);document.write(p.id);document.write(p.name);document.write(p.sal); js中定义对象使用函数，和Java不同，java使用类来创建。6.浏览器对象window,document,status,loaction,historywindow对象打开新窗口1window.open(&quot;index.jsp&quot;); 7.提交表单12345678910111213141516171819202122&lt;head&gt; &lt;title&gt;button提交表单&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;function.jsp&quot; method=&quot;POST&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;提交&quot;/&gt;s &lt;!--演示用js提交表单--&gt;&lt;/form&gt;&lt;script type=&quot;text/javascript&quot;&gt; //定位提交按钮，同时添加单击事件 var inputElement = document.getElementsByTagName(&quot;input&quot;)[0]; //为提交按钮添加单机事件 inputElement.onclick = function () &#123; //定位&lt;form&gt;标签 //forms表示收集documen对象中所有表单&lt;form&gt;的集合，下标从0开始 var formElement = document.forms[0]; //提交表单，提交到action 指定的地方 formElement.submit(); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax之同步异步请求]]></title>
    <url>%2F2017%2F09%2F17%2Fajax%E4%B9%8B%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[#ajax是可以与服务器进行交互的技术之一同步请求：同一时间点只允许执行一个进程异步请求：同一时间点允许执行多个进程ajax请求方式：ajax对象.open(get/post方式，url地址,异步true/同步) ##1.同步请求如下：12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; alert(1234); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;ajax study&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 以上代码中问题是，先看到弹出框还是先看到标题或者是两者同时看到？实际实践中，我们是先看到弹出框点击确定之后才能看到标题。这样的过程叫做同步请求，即同一时间只有一个进程在执行。 ##异步请求客户端：1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if(xhr.readyState==4)&#123; alert(xhr.responseText); &#125; &#125; xhr.open(&apos;get&apos;,&apos;./08.php&apos;); xhr.send(null); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;ajax study&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 服务器端：123&lt;?phpecho &quot;jinxiaomei&quot;; 效果：同时看到弹出框和h2标签 ###总结： 1.ajax绝大情况下使用异步请求。 2.使用同步请求的情况可能如下：如页面包含两个部分ajax请求内容和正常的HTML内容的输出，如果HTML内容的输出包含ajax请求的内容，那么就得要求两者一前一后调用而非两者同时调用。即需要进行同步请求。]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax之post请求]]></title>
    <url>%2F2017%2F09%2F17%2Fajax%E4%B9%8Bpost%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[##ajax的post请求方式有以下四个需要注意的地方1.给服务器传递数据需要调用send(请求字符串数据)方法。2.需要调用方法setRequestHeader()把传递的数据组织为xml格式（模仿form表单传递数据）。3.传递的中文信息无需编码，特殊符号像&amp;、=等仍然需要编码。4.该请求方式也可以传递get参数，接受的时候使用$_GET接受。 ##以上1,2两点代码示例客户端代码：123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function checkname() &#123; //获得用户名信息，传递给服务器端 var nm = document.getElementById(&apos;username&apos;).value; //对nm的特殊符号（&amp;、=）进行编码处理,当输入name=xiao$pa=12时，浏览器会解析出pa，所以要处理一下 // nm =encodeURIComponent(nm); //把传递给服务器端的数据组织为请求字符串 var info = &apos;name=&apos;+nm+&apos;&amp;color=yellow&apos;; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if(xhr.readyState==4)&#123; alert(xhr.responseText) &#125; &#125; xhr.open(&apos;post&apos;,&apos;./06.php&apos;); //post方式是把数据没模拟为form表单的形式提交给服务器 //form表单的形式是组织成xml格式发送给服务器 //以下setRequestHeader必须在post方法之后，作用是把传递的数据组织成xml形式 xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(info); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;ajax之post用户名校验&lt;/h2&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; onblur=&quot;checkname()&quot;&gt;&lt;br/&gt;&lt;p/&gt;&lt;!--失去焦点事件--&gt;密 码： &lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;&lt;/body&gt;&lt;/html&gt; 服务器端代码：（注意用post接受）1234567891011121314&lt;?php//服务器端用户名校验$exists_name = array(&apos;mary&apos;,&apos;jack&apos;,&apos;linken&apos;,&apos;tom&apos;);//输出客户端传递过来的用户名信息$name = $_GET[&apos;name&apos;];print_r($_POST);/*//判断用户输入名字是否存在if(in_array($name,$exists_name))&#123; echo&quot;用户名已经被占用&quot;;&#125;else&#123; echo &quot;用户名可以使用&quot;;&#125;*/ ##3,4两点的代码示例服务器端：123456789101112131415&lt;?php//服务器端用户名校验$exists_name = array(&apos;mary&apos;,&apos;jack&apos;,&apos;linken&apos;,&apos;tom&apos;);//输出客户端传递过来的用户名信息$name = $_GET[&apos;name&apos;];print_r($_POST);print_r($_GET);/*//判断用户输入名字是否存在if(in_array($name,$exists_name))&#123; echo&quot;用户名已经被占用&quot;;&#125;else&#123; echo &quot;用户名可以使用&quot;;&#125;*/ 客户端：123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function checkname() &#123; //获得用户名信息，传递给服务器端 var nm = document.getElementById(&apos;username&apos;).value; //对nm的特殊符号（&amp;、=）进行编码处理,当输入name=xiao$pa=12时，浏览器会解析出pa，所以要处理一下 nm =encodeURIComponent(nm); //把传递给服务器端的数据组织为请求字符串 var info = &apos;name=&apos;+nm+&apos;&amp;color=yellow&apos;; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if(xhr.readyState==4)&#123; alert(xhr.responseText) &#125; &#125; xhr.open(&apos;post&apos;,&apos;./06.php?age=20&apos;); //post方式是把数据没模拟为form表单的形式提交给服务器 //form表单的形式是组织成xml格式发送给服务器 //以下setRequestHeader必须在post方法之后，作用是把传递的数据组织成xml形式 xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(info); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;ajax之post用户名校验&lt;/h2&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; onblur=&quot;checkname()&quot;&gt;&lt;br/&gt;&lt;p/&gt;&lt;!--失去焦点事件--&gt;密 码： &lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;&lt;/body&gt;&lt;/html&gt; 注意的一点：post请求中后面的的第一个参数前是？不是&amp;，如果有多个参数，那么参数之间用&amp;连接。]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax中的get请求]]></title>
    <url>%2F2017%2F09%2F17%2Fajax%E4%B8%AD%E7%9A%84get%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[环境：wampajax中get请求需要注意两点： （1）在url地址后面以请求字符串（传递的get参数信息）形式传递数据 （2）对中文 、=、&amp;等特殊符号需要进行处理。在浏览器中传递一些特殊符号信息会被混淆误解，如&amp;、=，浏览器会把这样的信息当成get请求参数的一部分精心错误的解析，这时，可以对该信息进行编码处理。 如下： 服务端代码04.php1234567891011121314&lt;?php//服务器端用户名校验$exists_name = array(&apos;mary&apos;,&apos;jack&apos;,&apos;linken&apos;,&apos;tom&apos;);//输出客户端传递过来的用户名信息$name = $_GET[&apos;name&apos;];print_r($_GET);/*//判断用户输入名字是否存在if(in_array($name,$exists_name))&#123; echo&quot;用户名已经被占用&quot;;&#125;else&#123; echo &quot;用户名可以使用&quot;;&#125;*/ 客户端代码04-get.html1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function checkname() &#123; //获得用户名信息，传递给服务器端 var nm = document.getElementById(&apos;username&apos;).value; //对nm的特殊符号（&amp;、=）进行编码处理,当输入name=xiao$pa=12时，浏览器会解析出pa，所以要处理一下 nm =encodeURIComponent(nm); var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function () &#123; if(xhr.readyState==4)&#123; alert(xhr.responseText) &#125; &#125; xhr.open(&apos;get&apos;,&apos;./04.php?name=&apos;+nm+&apos;&amp;age=20&apos;); xhr.send(null); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;ajax之用户名校验&lt;/h2&gt;用户名：&lt;input type=&quot;text&quot; id=&quot;username&quot; onblur=&quot;checkname()&quot;&gt;&lt;br/&gt;&lt;p/&gt;&lt;!--失去焦点事件--&gt;密 码： &lt;input type=&quot;text&quot; id=&quot;password&quot;&gt;&lt;/body&gt;&lt;/html&gt; 这两段代码放在wamp的www目录下，在浏览器中输入客户端地址，用户名填写jin&amp;ps=jin这样写时，如果没有这一句对特殊信息的编码nm =encodeURIComponent(nm);浏览器会以为ps也是一个参数而不是名字的一部分。]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习ajax一]]></title>
    <url>%2F2017%2F09%2F16%2Fajax%E5%AD%A6%E4%B9%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[1.定义：异步的javascript和xml,是可以与服务器进行交互的（异步）技术之一。其是浏览器的技术。最大的特点：页面不刷新。 2.ajax页面不刷新的特点是什么意思：例如，当我们在百度搜索框中输入“中国”，是ajax带着这两个字去服务器请求，并查询相关的信息后返回。 3.理解ajax:当我们在注册一个网站时，将用户名输入后，需要校验用户名，如果该用户名已经被注册，则会提示该用户名已经被注册。在这个过程中，我们提交的所有信息都会被带到服务器校验，当用户名注册不成功时，页面会刷新，其他的信息都会清空，这个时候我们不仅需要修改用户名，还要重新添加之前已经注册了的其他信息。又要讲这些信息重新提交给服务器，浪费服务器带宽。但是使用ajax时，ajax仅仅将用户名带到服务器校验，用户名不成功时，页面不刷新，其他信息不会被清空。带宽上只验证用户名一个项目，节省带宽。 4.创建ajax的方式： xhr 12345.利用ajax发起对服务器端的请求步骤如下： （１）创建ajax对象。 ``` var xhr = new XMLHttpRequest(); （２）创建一个新的http请求HTTP请求协议，并设置请求的服务器端的地址。设置方式：对象.open(请求方式 get/post,url服务器端地址)。 './02.php');```12 （3）把HTTP请求发送给服务器，方式：对象.send(get写null(post方式写上post的请求数据)) ``` xhr.send(null); （4）02.php内容如下（php文件代表服务器端应用程序）：1234567 &lt;?php//给当前目录的一个文件追加内容,以追加的方式打开，如果没有这个文件则自动创建这个文件$fp = fopen(&quot;./02.txt&quot;,&quot;a&quot;);fwrite($fp,&apos;php0710&apos;);//给文件追加写入内容fclose($fp);//关闭文件 6.ajax接受服务器端返回信息 （１）ajax可以接受浏览器所能接受的所有信息。ajax接受返回的信息，需要结合readyState/onreadyStatechange/responseText属性一并操作。 代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 &lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=&quot;text/javascript&quot;&gt; function f1() &#123; /*ajax对象可以访问的成员 * 属性： * responseText:以字符串形式接受服务器返回的信息 * readyState:ajax 对象的状态 *0：创建ajax对象 * 1.有调用open方法 * 2.调用send方法 * 3.只返回了一部分数据 * 4.代表数据返回完整 *onreadyStatechange:是ajax的时间，在readyState状态发生变化时被触发，为了感知最多的状态信息，要设置在对象创建完毕之后,最多可以感知1234一共四个状态信息。 *responseXML:将响应信息格式化未xml document对象并返回 *state:返回当前请求的http的状态码 stateText：返回当前请求的状态行信息 * 方法： *open * send * */ //1.创建ajax请求 var xhr = new XMLHttpRequest(); //4.ajax状态的变化，当==4的时候返回信息 xhr.onreadystatechange = function () &#123; //要随时感知ajax状态的变化 if(xhr.readyState==4) &#123; //将ajax返回的信息显示在页面 document.getElementById(&apos;result&apos;).innerHTML = xhr.responseText; &#125; &#125; //2.创建新的HTTP请求协议，设置请求方式和地址 xhr.open(&apos;get&apos;,&apos;./03.php&apos;); //3.发送ajax请求 xhr.send(null); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;ajax接受服务器端返回的信息&lt;/h2&gt;&lt;input type=&quot;button&quot; value=&quot;触发&quot; onclick=&quot;f1()&quot;&gt;&lt;div id=&quot;result&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 从上面这段代码中，ajax对象一共有五种状态，分别界面如下： 0（未初始化）：对象已经建立，但是尚未初始化（尚未调用open方法） 1（初始化）：对象已经建立，尚未调用send方法 2（发送数据）：send方法已经调用，但是当前的状态以及http头未知 3(数据传送中)：已接收部分数据，因为相应以及HTTP头未全，这时通过responseBody和responseText获取部分数据会出现错误。 *4（完成）：数据接收完毕，此时可以通过responsebody和responseText获取完成的响应数据. 状态码和状态值： state—-stateText 200——ok 304——not modified 代表已经缓存 404——not found 没有此页面 403—— not forbidden 禁止访问，服务器端 50X——服务器端有错误]]></content>
      <tags>
        <tag>ajax</tag>
      </tags>
  </entry>
</search>
